{"version":3,"sources":["webpack:///./src/node_modules/engine.io-client/lib/transports/websocket.js"],"names":["Buffer","BrowserWebSocket","NodeWebSocket","Transport","__webpack_require__","parser","parseqs","inherit","yeast","debug","WebSocket","self","MozWebSocket","e","WebSocketImpl","WS","opts","forceBase64","this","supportsBinary","perMessageDeflate","usingBrowserWebSocket","forceNode","protocols","call","module","exports","prototype","name","doOpen","check","uri","agent","pfx","key","passphrase","cert","ca","ciphers","rejectUnauthorized","extraHeaders","headers","localAddress","ws","isReactNative","err","emit","undefined","binaryType","supports","binary","addEventListeners","onopen","onOpen","onclose","onClose","onmessage","ev","onData","data","onerror","onError","write","packets","writable","total","length","i","l","packet","encodePacket","options","compress","len","byteLength","threshold","send","done","setTimeout","doClose","close","query","schema","secure","port","Number","timestampRequests","timestampParam","b64","encode","ipv6","hostname","indexOf","path"],"mappings":"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","file":"js/chunk-vendors~bc36c65d.e1e1b3da.js","sourcesContent":["/**\n * Module dependencies.\n */\n\nvar Transport = require('../transport');\nvar parser = require('engine.io-parser');\nvar parseqs = require('parseqs');\nvar inherit = require('component-inherit');\nvar yeast = require('yeast');\nvar debug = require('debug')('engine.io-client:websocket');\n\nvar BrowserWebSocket, NodeWebSocket;\n\nif (typeof WebSocket !== 'undefined') {\n  BrowserWebSocket = WebSocket;\n} else if (typeof self !== 'undefined') {\n  BrowserWebSocket = self.WebSocket || self.MozWebSocket;\n} else {\n  try {\n    NodeWebSocket = require('ws');\n  } catch (e) { }\n}\n\n/**\n * Get either the `WebSocket` or `MozWebSocket` globals\n * in the browser or try to resolve WebSocket-compatible\n * interface exposed by `ws` for Node-like environment.\n */\n\nvar WebSocketImpl = BrowserWebSocket || NodeWebSocket;\n\n/**\n * Module exports.\n */\n\nmodule.exports = WS;\n\n/**\n * WebSocket transport constructor.\n *\n * @api {Object} connection options\n * @api public\n */\n\nfunction WS (opts) {\n  var forceBase64 = (opts && opts.forceBase64);\n  if (forceBase64) {\n    this.supportsBinary = false;\n  }\n  this.perMessageDeflate = opts.perMessageDeflate;\n  this.usingBrowserWebSocket = BrowserWebSocket && !opts.forceNode;\n  this.protocols = opts.protocols;\n  if (!this.usingBrowserWebSocket) {\n    WebSocketImpl = NodeWebSocket;\n  }\n  Transport.call(this, opts);\n}\n\n/**\n * Inherits from Transport.\n */\n\ninherit(WS, Transport);\n\n/**\n * Transport name.\n *\n * @api public\n */\n\nWS.prototype.name = 'websocket';\n\n/*\n * WebSockets support binary\n */\n\nWS.prototype.supportsBinary = true;\n\n/**\n * Opens socket.\n *\n * @api private\n */\n\nWS.prototype.doOpen = function () {\n  if (!this.check()) {\n    // let probe timeout\n    return;\n  }\n\n  var uri = this.uri();\n  var protocols = this.protocols;\n  var opts = {\n    agent: this.agent,\n    perMessageDeflate: this.perMessageDeflate\n  };\n\n  // SSL options for Node.js client\n  opts.pfx = this.pfx;\n  opts.key = this.key;\n  opts.passphrase = this.passphrase;\n  opts.cert = this.cert;\n  opts.ca = this.ca;\n  opts.ciphers = this.ciphers;\n  opts.rejectUnauthorized = this.rejectUnauthorized;\n  if (this.extraHeaders) {\n    opts.headers = this.extraHeaders;\n  }\n  if (this.localAddress) {\n    opts.localAddress = this.localAddress;\n  }\n\n  try {\n    this.ws =\n      this.usingBrowserWebSocket && !this.isReactNative\n        ? protocols\n          ? new WebSocketImpl(uri, protocols)\n          : new WebSocketImpl(uri)\n        : new WebSocketImpl(uri, protocols, opts);\n  } catch (err) {\n    return this.emit('error', err);\n  }\n\n  if (this.ws.binaryType === undefined) {\n    this.supportsBinary = false;\n  }\n\n  if (this.ws.supports && this.ws.supports.binary) {\n    this.supportsBinary = true;\n    this.ws.binaryType = 'nodebuffer';\n  } else {\n    this.ws.binaryType = 'arraybuffer';\n  }\n\n  this.addEventListeners();\n};\n\n/**\n * Adds event listeners to the socket\n *\n * @api private\n */\n\nWS.prototype.addEventListeners = function () {\n  var self = this;\n\n  this.ws.onopen = function () {\n    self.onOpen();\n  };\n  this.ws.onclose = function () {\n    self.onClose();\n  };\n  this.ws.onmessage = function (ev) {\n    self.onData(ev.data);\n  };\n  this.ws.onerror = function (e) {\n    self.onError('websocket error', e);\n  };\n};\n\n/**\n * Writes data to socket.\n *\n * @param {Array} array of packets.\n * @api private\n */\n\nWS.prototype.write = function (packets) {\n  var self = this;\n  this.writable = false;\n\n  // encodePacket efficient as it uses WS framing\n  // no need for encodePayload\n  var total = packets.length;\n  for (var i = 0, l = total; i < l; i++) {\n    (function (packet) {\n      parser.encodePacket(packet, self.supportsBinary, function (data) {\n        if (!self.usingBrowserWebSocket) {\n          // always create a new object (GH-437)\n          var opts = {};\n          if (packet.options) {\n            opts.compress = packet.options.compress;\n          }\n\n          if (self.perMessageDeflate) {\n            var len = 'string' === typeof data ? Buffer.byteLength(data) : data.length;\n            if (len < self.perMessageDeflate.threshold) {\n              opts.compress = false;\n            }\n          }\n        }\n\n        // Sometimes the websocket has already been closed but the browser didn't\n        // have a chance of informing us about it yet, in that case send will\n        // throw an error\n        try {\n          if (self.usingBrowserWebSocket) {\n            // TypeError is thrown when passing the second argument on Safari\n            self.ws.send(data);\n          } else {\n            self.ws.send(data, opts);\n          }\n        } catch (e) {\n          debug('websocket closed before onclose event');\n        }\n\n        --total || done();\n      });\n    })(packets[i]);\n  }\n\n  function done () {\n    self.emit('flush');\n\n    // fake drain\n    // defer to next tick to allow Socket to clear writeBuffer\n    setTimeout(function () {\n      self.writable = true;\n      self.emit('drain');\n    }, 0);\n  }\n};\n\n/**\n * Called upon close\n *\n * @api private\n */\n\nWS.prototype.onClose = function () {\n  Transport.prototype.onClose.call(this);\n};\n\n/**\n * Closes socket.\n *\n * @api private\n */\n\nWS.prototype.doClose = function () {\n  if (typeof this.ws !== 'undefined') {\n    this.ws.close();\n  }\n};\n\n/**\n * Generates uri for connection.\n *\n * @api private\n */\n\nWS.prototype.uri = function () {\n  var query = this.query || {};\n  var schema = this.secure ? 'wss' : 'ws';\n  var port = '';\n\n  // avoid port if default for schema\n  if (this.port && (('wss' === schema && Number(this.port) !== 443) ||\n    ('ws' === schema && Number(this.port) !== 80))) {\n    port = ':' + this.port;\n  }\n\n  // append timestamp to URI\n  if (this.timestampRequests) {\n    query[this.timestampParam] = yeast();\n  }\n\n  // communicate binary support capabilities\n  if (!this.supportsBinary) {\n    query.b64 = 1;\n  }\n\n  query = parseqs.encode(query);\n\n  // prepend ? to query\n  if (query.length) {\n    query = '?' + query;\n  }\n\n  var ipv6 = this.hostname.indexOf(':') !== -1;\n  return schema + '://' + (ipv6 ? '[' + this.hostname + ']' : this.hostname) + port + this.path + query;\n};\n\n/**\n * Feature detection for WebSocket.\n *\n * @return {Boolean} whether this transport is available.\n * @api public\n */\n\nWS.prototype.check = function () {\n  return !!WebSocketImpl && !('__initialize' in WebSocketImpl && this.name === WS.prototype.name);\n};\n"],"sourceRoot":""}