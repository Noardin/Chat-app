{"version":3,"sources":["webpack:///./src/node_modules/socket.io-client/lib/url.js","webpack:///./src/node_modules/socket.io-client/lib/on.js","webpack:///./src/node_modules/socket.io-client/lib/manager.js","webpack:///./src/node_modules/socket.io-client/lib/index.js","webpack:///./src/node_modules/socket.io-client/lib/socket.js"],"names":["parseuri","__webpack_require__","debug","url","uri","loc","obj","location","protocol","host","charAt","test","port","path","ipv6","indexOf","id","href","module","exports","on","ev","fn","destroy","removeListener","eio","Socket","Emitter","parser","bind","Backoff","has","Object","prototype","hasOwnProperty","Manager","opts","this","undefined","nsps","subs","reconnection","reconnectionAttempts","Infinity","reconnectionDelay","reconnectionDelayMax","randomizationFactor","backoff","min","max","jitter","timeout","readyState","connecting","lastPing","encoding","packetBuffer","_parser","encoder","Encoder","decoder","Decoder","autoConnect","open","emitAll","nsp","emit","apply","arguments","call","updateSocketIds","generateId","engine","v","length","_reconnection","_reconnectionAttempts","_reconnectionDelay","setMin","_randomizationFactor","setJitter","_reconnectionDelayMax","setMax","_timeout","maybeReconnectOnOpen","reconnecting","attempts","reconnect","connect","socket","self","skipReconnect","openSub","onopen","errorSub","data","cleanup","err","Error","timer","setTimeout","close","push","clearTimeout","onping","Date","onpong","ondata","add","ondecoded","packet","onerror","onConnecting","index","splice","query","type","encode","encodedPackets","i","write","options","processPacketQueue","pack","shift","subsLength","sub","disconnect","reset","onclose","reason","delay","duration","onreconnect","attempt","lookup","cache","managers","io","parsed","source","sameNamespace","newConnection","forceNew","multiplex","toArray","parseqs","hasBin","events","connect_error","connect_timeout","error","reconnect_attempt","reconnect_failed","reconnect_error","ping","pong","json","ids","acks","receiveBuffer","sendBuffer","connected","disconnected","flags","subEvents","send","args","unshift","binary","BINARY_EVENT","EVENT","compress","pop","CONNECT","onpacket","rootNamespaceError","ERROR","onconnect","onevent","ACK","onack","BINARY_ACK","DISCONNECT","ondisconnect","ack","sent","emitBuffered"],"mappings":"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","file":"js/chunk-vendors~cd3831ce.48f91483.js","sourcesContent":["\n/**\n * Module dependencies.\n */\n\nvar parseuri = require('parseuri');\nvar debug = require('debug')('socket.io-client:url');\n\n/**\n * Module exports.\n */\n\nmodule.exports = url;\n\n/**\n * URL parser.\n *\n * @param {String} url\n * @param {Object} An object meant to mimic window.location.\n *                 Defaults to window.location.\n * @api public\n */\n\nfunction url (uri, loc) {\n  var obj = uri;\n\n  // default to window.location\n  loc = loc || (typeof location !== 'undefined' && location);\n  if (null == uri) uri = loc.protocol + '//' + loc.host;\n\n  // relative path support\n  if ('string' === typeof uri) {\n    if ('/' === uri.charAt(0)) {\n      if ('/' === uri.charAt(1)) {\n        uri = loc.protocol + uri;\n      } else {\n        uri = loc.host + uri;\n      }\n    }\n\n    if (!/^(https?|wss?):\\/\\//.test(uri)) {\n      debug('protocol-less url %s', uri);\n      if ('undefined' !== typeof loc) {\n        uri = loc.protocol + '//' + uri;\n      } else {\n        uri = 'https://' + uri;\n      }\n    }\n\n    // parse\n    debug('parse %s', uri);\n    obj = parseuri(uri);\n  }\n\n  // make sure we treat `localhost:80` and `localhost` equally\n  if (!obj.port) {\n    if (/^(http|ws)$/.test(obj.protocol)) {\n      obj.port = '80';\n    } else if (/^(http|ws)s$/.test(obj.protocol)) {\n      obj.port = '443';\n    }\n  }\n\n  obj.path = obj.path || '/';\n\n  var ipv6 = obj.host.indexOf(':') !== -1;\n  var host = ipv6 ? '[' + obj.host + ']' : obj.host;\n\n  // define unique id\n  obj.id = obj.protocol + '://' + host + ':' + obj.port;\n  // define href\n  obj.href = obj.protocol + '://' + host + (loc && loc.port === obj.port ? '' : (':' + obj.port));\n\n  return obj;\n}\n","\n/**\n * Module exports.\n */\n\nmodule.exports = on;\n\n/**\n * Helper for subscriptions.\n *\n * @param {Object|EventEmitter} obj with `Emitter` mixin or `EventEmitter`\n * @param {String} event name\n * @param {Function} callback\n * @api public\n */\n\nfunction on (obj, ev, fn) {\n  obj.on(ev, fn);\n  return {\n    destroy: function () {\n      obj.removeListener(ev, fn);\n    }\n  };\n}\n","\n/**\n * Module dependencies.\n */\n\nvar eio = require('engine.io-client');\nvar Socket = require('./socket');\nvar Emitter = require('component-emitter');\nvar parser = require('socket.io-parser');\nvar on = require('./on');\nvar bind = require('component-bind');\nvar debug = require('debug')('socket.io-client:manager');\nvar indexOf = require('indexof');\nvar Backoff = require('backo2');\n\n/**\n * IE6+ hasOwnProperty\n */\n\nvar has = Object.prototype.hasOwnProperty;\n\n/**\n * Module exports\n */\n\nmodule.exports = Manager;\n\n/**\n * `Manager` constructor.\n *\n * @param {String} engine instance or engine uri/opts\n * @param {Object} options\n * @api public\n */\n\nfunction Manager (uri, opts) {\n  if (!(this instanceof Manager)) return new Manager(uri, opts);\n  if (uri && ('object' === typeof uri)) {\n    opts = uri;\n    uri = undefined;\n  }\n  opts = opts || {};\n\n  opts.path = opts.path || '/socket.io';\n  this.nsps = {};\n  this.subs = [];\n  this.opts = opts;\n  this.reconnection(opts.reconnection !== false);\n  this.reconnectionAttempts(opts.reconnectionAttempts || Infinity);\n  this.reconnectionDelay(opts.reconnectionDelay || 1000);\n  this.reconnectionDelayMax(opts.reconnectionDelayMax || 5000);\n  this.randomizationFactor(opts.randomizationFactor || 0.5);\n  this.backoff = new Backoff({\n    min: this.reconnectionDelay(),\n    max: this.reconnectionDelayMax(),\n    jitter: this.randomizationFactor()\n  });\n  this.timeout(null == opts.timeout ? 20000 : opts.timeout);\n  this.readyState = 'closed';\n  this.uri = uri;\n  this.connecting = [];\n  this.lastPing = null;\n  this.encoding = false;\n  this.packetBuffer = [];\n  var _parser = opts.parser || parser;\n  this.encoder = new _parser.Encoder();\n  this.decoder = new _parser.Decoder();\n  this.autoConnect = opts.autoConnect !== false;\n  if (this.autoConnect) this.open();\n}\n\n/**\n * Propagate given event to sockets and emit on `this`\n *\n * @api private\n */\n\nManager.prototype.emitAll = function () {\n  this.emit.apply(this, arguments);\n  for (var nsp in this.nsps) {\n    if (has.call(this.nsps, nsp)) {\n      this.nsps[nsp].emit.apply(this.nsps[nsp], arguments);\n    }\n  }\n};\n\n/**\n * Update `socket.id` of all sockets\n *\n * @api private\n */\n\nManager.prototype.updateSocketIds = function () {\n  for (var nsp in this.nsps) {\n    if (has.call(this.nsps, nsp)) {\n      this.nsps[nsp].id = this.generateId(nsp);\n    }\n  }\n};\n\n/**\n * generate `socket.id` for the given `nsp`\n *\n * @param {String} nsp\n * @return {String}\n * @api private\n */\n\nManager.prototype.generateId = function (nsp) {\n  return (nsp === '/' ? '' : (nsp + '#')) + this.engine.id;\n};\n\n/**\n * Mix in `Emitter`.\n */\n\nEmitter(Manager.prototype);\n\n/**\n * Sets the `reconnection` config.\n *\n * @param {Boolean} true/false if it should automatically reconnect\n * @return {Manager} self or value\n * @api public\n */\n\nManager.prototype.reconnection = function (v) {\n  if (!arguments.length) return this._reconnection;\n  this._reconnection = !!v;\n  return this;\n};\n\n/**\n * Sets the reconnection attempts config.\n *\n * @param {Number} max reconnection attempts before giving up\n * @return {Manager} self or value\n * @api public\n */\n\nManager.prototype.reconnectionAttempts = function (v) {\n  if (!arguments.length) return this._reconnectionAttempts;\n  this._reconnectionAttempts = v;\n  return this;\n};\n\n/**\n * Sets the delay between reconnections.\n *\n * @param {Number} delay\n * @return {Manager} self or value\n * @api public\n */\n\nManager.prototype.reconnectionDelay = function (v) {\n  if (!arguments.length) return this._reconnectionDelay;\n  this._reconnectionDelay = v;\n  this.backoff && this.backoff.setMin(v);\n  return this;\n};\n\nManager.prototype.randomizationFactor = function (v) {\n  if (!arguments.length) return this._randomizationFactor;\n  this._randomizationFactor = v;\n  this.backoff && this.backoff.setJitter(v);\n  return this;\n};\n\n/**\n * Sets the maximum delay between reconnections.\n *\n * @param {Number} delay\n * @return {Manager} self or value\n * @api public\n */\n\nManager.prototype.reconnectionDelayMax = function (v) {\n  if (!arguments.length) return this._reconnectionDelayMax;\n  this._reconnectionDelayMax = v;\n  this.backoff && this.backoff.setMax(v);\n  return this;\n};\n\n/**\n * Sets the connection timeout. `false` to disable\n *\n * @return {Manager} self or value\n * @api public\n */\n\nManager.prototype.timeout = function (v) {\n  if (!arguments.length) return this._timeout;\n  this._timeout = v;\n  return this;\n};\n\n/**\n * Starts trying to reconnect if reconnection is enabled and we have not\n * started reconnecting yet\n *\n * @api private\n */\n\nManager.prototype.maybeReconnectOnOpen = function () {\n  // Only try to reconnect if it's the first time we're connecting\n  if (!this.reconnecting && this._reconnection && this.backoff.attempts === 0) {\n    // keeps reconnection from firing twice for the same reconnection loop\n    this.reconnect();\n  }\n};\n\n/**\n * Sets the current transport `socket`.\n *\n * @param {Function} optional, callback\n * @return {Manager} self\n * @api public\n */\n\nManager.prototype.open =\nManager.prototype.connect = function (fn, opts) {\n  debug('readyState %s', this.readyState);\n  if (~this.readyState.indexOf('open')) return this;\n\n  debug('opening %s', this.uri);\n  this.engine = eio(this.uri, this.opts);\n  var socket = this.engine;\n  var self = this;\n  this.readyState = 'opening';\n  this.skipReconnect = false;\n\n  // emit `open`\n  var openSub = on(socket, 'open', function () {\n    self.onopen();\n    fn && fn();\n  });\n\n  // emit `connect_error`\n  var errorSub = on(socket, 'error', function (data) {\n    debug('connect_error');\n    self.cleanup();\n    self.readyState = 'closed';\n    self.emitAll('connect_error', data);\n    if (fn) {\n      var err = new Error('Connection error');\n      err.data = data;\n      fn(err);\n    } else {\n      // Only do this if there is no fn to handle the error\n      self.maybeReconnectOnOpen();\n    }\n  });\n\n  // emit `connect_timeout`\n  if (false !== this._timeout) {\n    var timeout = this._timeout;\n    debug('connect attempt will timeout after %d', timeout);\n\n    // set timer\n    var timer = setTimeout(function () {\n      debug('connect attempt timed out after %d', timeout);\n      openSub.destroy();\n      socket.close();\n      socket.emit('error', 'timeout');\n      self.emitAll('connect_timeout', timeout);\n    }, timeout);\n\n    this.subs.push({\n      destroy: function () {\n        clearTimeout(timer);\n      }\n    });\n  }\n\n  this.subs.push(openSub);\n  this.subs.push(errorSub);\n\n  return this;\n};\n\n/**\n * Called upon transport open.\n *\n * @api private\n */\n\nManager.prototype.onopen = function () {\n  debug('open');\n\n  // clear old subs\n  this.cleanup();\n\n  // mark as open\n  this.readyState = 'open';\n  this.emit('open');\n\n  // add new subs\n  var socket = this.engine;\n  this.subs.push(on(socket, 'data', bind(this, 'ondata')));\n  this.subs.push(on(socket, 'ping', bind(this, 'onping')));\n  this.subs.push(on(socket, 'pong', bind(this, 'onpong')));\n  this.subs.push(on(socket, 'error', bind(this, 'onerror')));\n  this.subs.push(on(socket, 'close', bind(this, 'onclose')));\n  this.subs.push(on(this.decoder, 'decoded', bind(this, 'ondecoded')));\n};\n\n/**\n * Called upon a ping.\n *\n * @api private\n */\n\nManager.prototype.onping = function () {\n  this.lastPing = new Date();\n  this.emitAll('ping');\n};\n\n/**\n * Called upon a packet.\n *\n * @api private\n */\n\nManager.prototype.onpong = function () {\n  this.emitAll('pong', new Date() - this.lastPing);\n};\n\n/**\n * Called with data.\n *\n * @api private\n */\n\nManager.prototype.ondata = function (data) {\n  this.decoder.add(data);\n};\n\n/**\n * Called when parser fully decodes a packet.\n *\n * @api private\n */\n\nManager.prototype.ondecoded = function (packet) {\n  this.emit('packet', packet);\n};\n\n/**\n * Called upon socket error.\n *\n * @api private\n */\n\nManager.prototype.onerror = function (err) {\n  debug('error', err);\n  this.emitAll('error', err);\n};\n\n/**\n * Creates a new socket for the given `nsp`.\n *\n * @return {Socket}\n * @api public\n */\n\nManager.prototype.socket = function (nsp, opts) {\n  var socket = this.nsps[nsp];\n  if (!socket) {\n    socket = new Socket(this, nsp, opts);\n    this.nsps[nsp] = socket;\n    var self = this;\n    socket.on('connecting', onConnecting);\n    socket.on('connect', function () {\n      socket.id = self.generateId(nsp);\n    });\n\n    if (this.autoConnect) {\n      // manually call here since connecting event is fired before listening\n      onConnecting();\n    }\n  }\n\n  function onConnecting () {\n    if (!~indexOf(self.connecting, socket)) {\n      self.connecting.push(socket);\n    }\n  }\n\n  return socket;\n};\n\n/**\n * Called upon a socket close.\n *\n * @param {Socket} socket\n */\n\nManager.prototype.destroy = function (socket) {\n  var index = indexOf(this.connecting, socket);\n  if (~index) this.connecting.splice(index, 1);\n  if (this.connecting.length) return;\n\n  this.close();\n};\n\n/**\n * Writes a packet.\n *\n * @param {Object} packet\n * @api private\n */\n\nManager.prototype.packet = function (packet) {\n  debug('writing packet %j', packet);\n  var self = this;\n  if (packet.query && packet.type === 0) packet.nsp += '?' + packet.query;\n\n  if (!self.encoding) {\n    // encode, then write to engine with result\n    self.encoding = true;\n    this.encoder.encode(packet, function (encodedPackets) {\n      for (var i = 0; i < encodedPackets.length; i++) {\n        self.engine.write(encodedPackets[i], packet.options);\n      }\n      self.encoding = false;\n      self.processPacketQueue();\n    });\n  } else { // add packet to the queue\n    self.packetBuffer.push(packet);\n  }\n};\n\n/**\n * If packet buffer is non-empty, begins encoding the\n * next packet in line.\n *\n * @api private\n */\n\nManager.prototype.processPacketQueue = function () {\n  if (this.packetBuffer.length > 0 && !this.encoding) {\n    var pack = this.packetBuffer.shift();\n    this.packet(pack);\n  }\n};\n\n/**\n * Clean up transport subscriptions and packet buffer.\n *\n * @api private\n */\n\nManager.prototype.cleanup = function () {\n  debug('cleanup');\n\n  var subsLength = this.subs.length;\n  for (var i = 0; i < subsLength; i++) {\n    var sub = this.subs.shift();\n    sub.destroy();\n  }\n\n  this.packetBuffer = [];\n  this.encoding = false;\n  this.lastPing = null;\n\n  this.decoder.destroy();\n};\n\n/**\n * Close the current socket.\n *\n * @api private\n */\n\nManager.prototype.close =\nManager.prototype.disconnect = function () {\n  debug('disconnect');\n  this.skipReconnect = true;\n  this.reconnecting = false;\n  if ('opening' === this.readyState) {\n    // `onclose` will not fire because\n    // an open event never happened\n    this.cleanup();\n  }\n  this.backoff.reset();\n  this.readyState = 'closed';\n  if (this.engine) this.engine.close();\n};\n\n/**\n * Called upon engine close.\n *\n * @api private\n */\n\nManager.prototype.onclose = function (reason) {\n  debug('onclose');\n\n  this.cleanup();\n  this.backoff.reset();\n  this.readyState = 'closed';\n  this.emit('close', reason);\n\n  if (this._reconnection && !this.skipReconnect) {\n    this.reconnect();\n  }\n};\n\n/**\n * Attempt a reconnection.\n *\n * @api private\n */\n\nManager.prototype.reconnect = function () {\n  if (this.reconnecting || this.skipReconnect) return this;\n\n  var self = this;\n\n  if (this.backoff.attempts >= this._reconnectionAttempts) {\n    debug('reconnect failed');\n    this.backoff.reset();\n    this.emitAll('reconnect_failed');\n    this.reconnecting = false;\n  } else {\n    var delay = this.backoff.duration();\n    debug('will wait %dms before reconnect attempt', delay);\n\n    this.reconnecting = true;\n    var timer = setTimeout(function () {\n      if (self.skipReconnect) return;\n\n      debug('attempting reconnect');\n      self.emitAll('reconnect_attempt', self.backoff.attempts);\n      self.emitAll('reconnecting', self.backoff.attempts);\n\n      // check again for the case socket closed in above events\n      if (self.skipReconnect) return;\n\n      self.open(function (err) {\n        if (err) {\n          debug('reconnect attempt error');\n          self.reconnecting = false;\n          self.reconnect();\n          self.emitAll('reconnect_error', err.data);\n        } else {\n          debug('reconnect success');\n          self.onreconnect();\n        }\n      });\n    }, delay);\n\n    this.subs.push({\n      destroy: function () {\n        clearTimeout(timer);\n      }\n    });\n  }\n};\n\n/**\n * Called upon successful reconnect.\n *\n * @api private\n */\n\nManager.prototype.onreconnect = function () {\n  var attempt = this.backoff.attempts;\n  this.reconnecting = false;\n  this.backoff.reset();\n  this.updateSocketIds();\n  this.emitAll('reconnect', attempt);\n};\n","\n/**\n * Module dependencies.\n */\n\nvar url = require('./url');\nvar parser = require('socket.io-parser');\nvar Manager = require('./manager');\nvar debug = require('debug')('socket.io-client');\n\n/**\n * Module exports.\n */\n\nmodule.exports = exports = lookup;\n\n/**\n * Managers cache.\n */\n\nvar cache = exports.managers = {};\n\n/**\n * Looks up an existing `Manager` for multiplexing.\n * If the user summons:\n *\n *   `io('http://localhost/a');`\n *   `io('http://localhost/b');`\n *\n * We reuse the existing instance based on same scheme/port/host,\n * and we initialize sockets for each namespace.\n *\n * @api public\n */\n\nfunction lookup (uri, opts) {\n  if (typeof uri === 'object') {\n    opts = uri;\n    uri = undefined;\n  }\n\n  opts = opts || {};\n\n  var parsed = url(uri);\n  var source = parsed.source;\n  var id = parsed.id;\n  var path = parsed.path;\n  var sameNamespace = cache[id] && path in cache[id].nsps;\n  var newConnection = opts.forceNew || opts['force new connection'] ||\n                      false === opts.multiplex || sameNamespace;\n\n  var io;\n\n  if (newConnection) {\n    debug('ignoring socket cache for %s', source);\n    io = Manager(source, opts);\n  } else {\n    if (!cache[id]) {\n      debug('new io instance for %s', source);\n      cache[id] = Manager(source, opts);\n    }\n    io = cache[id];\n  }\n  if (parsed.query && !opts.query) {\n    opts.query = parsed.query;\n  }\n  return io.socket(parsed.path, opts);\n}\n\n/**\n * Protocol version.\n *\n * @api public\n */\n\nexports.protocol = parser.protocol;\n\n/**\n * `connect`.\n *\n * @param {String} uri\n * @api public\n */\n\nexports.connect = lookup;\n\n/**\n * Expose constructors for standalone build.\n *\n * @api public\n */\n\nexports.Manager = require('./manager');\nexports.Socket = require('./socket');\n","\n/**\n * Module dependencies.\n */\n\nvar parser = require('socket.io-parser');\nvar Emitter = require('component-emitter');\nvar toArray = require('to-array');\nvar on = require('./on');\nvar bind = require('component-bind');\nvar debug = require('debug')('socket.io-client:socket');\nvar parseqs = require('parseqs');\nvar hasBin = require('has-binary2');\n\n/**\n * Module exports.\n */\n\nmodule.exports = exports = Socket;\n\n/**\n * Internal events (blacklisted).\n * These events can't be emitted by the user.\n *\n * @api private\n */\n\nvar events = {\n  connect: 1,\n  connect_error: 1,\n  connect_timeout: 1,\n  connecting: 1,\n  disconnect: 1,\n  error: 1,\n  reconnect: 1,\n  reconnect_attempt: 1,\n  reconnect_failed: 1,\n  reconnect_error: 1,\n  reconnecting: 1,\n  ping: 1,\n  pong: 1\n};\n\n/**\n * Shortcut to `Emitter#emit`.\n */\n\nvar emit = Emitter.prototype.emit;\n\n/**\n * `Socket` constructor.\n *\n * @api public\n */\n\nfunction Socket (io, nsp, opts) {\n  this.io = io;\n  this.nsp = nsp;\n  this.json = this; // compat\n  this.ids = 0;\n  this.acks = {};\n  this.receiveBuffer = [];\n  this.sendBuffer = [];\n  this.connected = false;\n  this.disconnected = true;\n  this.flags = {};\n  if (opts && opts.query) {\n    this.query = opts.query;\n  }\n  if (this.io.autoConnect) this.open();\n}\n\n/**\n * Mix in `Emitter`.\n */\n\nEmitter(Socket.prototype);\n\n/**\n * Subscribe to open, close and packet events\n *\n * @api private\n */\n\nSocket.prototype.subEvents = function () {\n  if (this.subs) return;\n\n  var io = this.io;\n  this.subs = [\n    on(io, 'open', bind(this, 'onopen')),\n    on(io, 'packet', bind(this, 'onpacket')),\n    on(io, 'close', bind(this, 'onclose'))\n  ];\n};\n\n/**\n * \"Opens\" the socket.\n *\n * @api public\n */\n\nSocket.prototype.open =\nSocket.prototype.connect = function () {\n  if (this.connected) return this;\n\n  this.subEvents();\n  this.io.open(); // ensure open\n  if ('open' === this.io.readyState) this.onopen();\n  this.emit('connecting');\n  return this;\n};\n\n/**\n * Sends a `message` event.\n *\n * @return {Socket} self\n * @api public\n */\n\nSocket.prototype.send = function () {\n  var args = toArray(arguments);\n  args.unshift('message');\n  this.emit.apply(this, args);\n  return this;\n};\n\n/**\n * Override `emit`.\n * If the event is in `events`, it's emitted normally.\n *\n * @param {String} event name\n * @return {Socket} self\n * @api public\n */\n\nSocket.prototype.emit = function (ev) {\n  if (events.hasOwnProperty(ev)) {\n    emit.apply(this, arguments);\n    return this;\n  }\n\n  var args = toArray(arguments);\n  var packet = {\n    type: (this.flags.binary !== undefined ? this.flags.binary : hasBin(args)) ? parser.BINARY_EVENT : parser.EVENT,\n    data: args\n  };\n\n  packet.options = {};\n  packet.options.compress = !this.flags || false !== this.flags.compress;\n\n  // event ack callback\n  if ('function' === typeof args[args.length - 1]) {\n    debug('emitting packet with ack id %d', this.ids);\n    this.acks[this.ids] = args.pop();\n    packet.id = this.ids++;\n  }\n\n  if (this.connected) {\n    this.packet(packet);\n  } else {\n    this.sendBuffer.push(packet);\n  }\n\n  this.flags = {};\n\n  return this;\n};\n\n/**\n * Sends a packet.\n *\n * @param {Object} packet\n * @api private\n */\n\nSocket.prototype.packet = function (packet) {\n  packet.nsp = this.nsp;\n  this.io.packet(packet);\n};\n\n/**\n * Called upon engine `open`.\n *\n * @api private\n */\n\nSocket.prototype.onopen = function () {\n  debug('transport is open - connecting');\n\n  // write connect packet if necessary\n  if ('/' !== this.nsp) {\n    if (this.query) {\n      var query = typeof this.query === 'object' ? parseqs.encode(this.query) : this.query;\n      debug('sending connect packet with query %s', query);\n      this.packet({type: parser.CONNECT, query: query});\n    } else {\n      this.packet({type: parser.CONNECT});\n    }\n  }\n};\n\n/**\n * Called upon engine `close`.\n *\n * @param {String} reason\n * @api private\n */\n\nSocket.prototype.onclose = function (reason) {\n  debug('close (%s)', reason);\n  this.connected = false;\n  this.disconnected = true;\n  delete this.id;\n  this.emit('disconnect', reason);\n};\n\n/**\n * Called with socket packet.\n *\n * @param {Object} packet\n * @api private\n */\n\nSocket.prototype.onpacket = function (packet) {\n  var sameNamespace = packet.nsp === this.nsp;\n  var rootNamespaceError = packet.type === parser.ERROR && packet.nsp === '/';\n\n  if (!sameNamespace && !rootNamespaceError) return;\n\n  switch (packet.type) {\n    case parser.CONNECT:\n      this.onconnect();\n      break;\n\n    case parser.EVENT:\n      this.onevent(packet);\n      break;\n\n    case parser.BINARY_EVENT:\n      this.onevent(packet);\n      break;\n\n    case parser.ACK:\n      this.onack(packet);\n      break;\n\n    case parser.BINARY_ACK:\n      this.onack(packet);\n      break;\n\n    case parser.DISCONNECT:\n      this.ondisconnect();\n      break;\n\n    case parser.ERROR:\n      this.emit('error', packet.data);\n      break;\n  }\n};\n\n/**\n * Called upon a server event.\n *\n * @param {Object} packet\n * @api private\n */\n\nSocket.prototype.onevent = function (packet) {\n  var args = packet.data || [];\n  debug('emitting event %j', args);\n\n  if (null != packet.id) {\n    debug('attaching ack callback to event');\n    args.push(this.ack(packet.id));\n  }\n\n  if (this.connected) {\n    emit.apply(this, args);\n  } else {\n    this.receiveBuffer.push(args);\n  }\n};\n\n/**\n * Produces an ack callback to emit with an event.\n *\n * @api private\n */\n\nSocket.prototype.ack = function (id) {\n  var self = this;\n  var sent = false;\n  return function () {\n    // prevent double callbacks\n    if (sent) return;\n    sent = true;\n    var args = toArray(arguments);\n    debug('sending ack %j', args);\n\n    self.packet({\n      type: hasBin(args) ? parser.BINARY_ACK : parser.ACK,\n      id: id,\n      data: args\n    });\n  };\n};\n\n/**\n * Called upon a server acknowlegement.\n *\n * @param {Object} packet\n * @api private\n */\n\nSocket.prototype.onack = function (packet) {\n  var ack = this.acks[packet.id];\n  if ('function' === typeof ack) {\n    debug('calling ack %s with %j', packet.id, packet.data);\n    ack.apply(this, packet.data);\n    delete this.acks[packet.id];\n  } else {\n    debug('bad ack %s', packet.id);\n  }\n};\n\n/**\n * Called upon server connect.\n *\n * @api private\n */\n\nSocket.prototype.onconnect = function () {\n  this.connected = true;\n  this.disconnected = false;\n  this.emit('connect');\n  this.emitBuffered();\n};\n\n/**\n * Emit buffered events (received and emitted).\n *\n * @api private\n */\n\nSocket.prototype.emitBuffered = function () {\n  var i;\n  for (i = 0; i < this.receiveBuffer.length; i++) {\n    emit.apply(this, this.receiveBuffer[i]);\n  }\n  this.receiveBuffer = [];\n\n  for (i = 0; i < this.sendBuffer.length; i++) {\n    this.packet(this.sendBuffer[i]);\n  }\n  this.sendBuffer = [];\n};\n\n/**\n * Called upon server disconnect.\n *\n * @api private\n */\n\nSocket.prototype.ondisconnect = function () {\n  debug('server disconnect (%s)', this.nsp);\n  this.destroy();\n  this.onclose('io server disconnect');\n};\n\n/**\n * Called upon forced client/server side disconnections,\n * this method ensures the manager stops tracking us and\n * that reconnections don't get triggered for this.\n *\n * @api private.\n */\n\nSocket.prototype.destroy = function () {\n  if (this.subs) {\n    // clean subscriptions to avoid reconnections\n    for (var i = 0; i < this.subs.length; i++) {\n      this.subs[i].destroy();\n    }\n    this.subs = null;\n  }\n\n  this.io.destroy(this);\n};\n\n/**\n * Disconnects the socket manually.\n *\n * @return {Socket} self\n * @api public\n */\n\nSocket.prototype.close =\nSocket.prototype.disconnect = function () {\n  if (this.connected) {\n    debug('performing disconnect (%s)', this.nsp);\n    this.packet({ type: parser.DISCONNECT });\n  }\n\n  // remove socket from pool\n  this.destroy();\n\n  if (this.connected) {\n    // fire events\n    this.onclose('io client disconnect');\n  }\n  return this;\n};\n\n/**\n * Sets the compress flag.\n *\n * @param {Boolean} if `true`, compresses the sending data\n * @return {Socket} self\n * @api public\n */\n\nSocket.prototype.compress = function (compress) {\n  this.flags.compress = compress;\n  return this;\n};\n\n/**\n * Sets the binary flag\n *\n * @param {Boolean} whether the emitted data contains binary\n * @return {Socket} self\n * @api public\n */\n\nSocket.prototype.binary = function (binary) {\n  this.flags.binary = binary;\n  return this;\n};\n"],"sourceRoot":""}