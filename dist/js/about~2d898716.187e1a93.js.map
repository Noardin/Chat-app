{"version":3,"sources":["webpack:///./node_modules/bootstrap-vue/src/utils/env.js","webpack:///./node_modules/bootstrap-vue/src/utils/array.js","webpack:///./node_modules/bootstrap-vue/src/utils/dom.js","webpack:///./node_modules/bootstrap-vue/src/utils/clone-deep.js","webpack:///./node_modules/bootstrap-vue/src/utils/get.js","webpack:///./node_modules/bootstrap-vue/src/utils/config.js"],"names":["process","__webpack_require__","d","__webpack_exports__","inBrowser","getNoWarn","document","window","documentElement","navigator","maxTouchPoints","Boolean","PointerEvent","MSPointerEvent","Object","NODE_ENV","BASE_URL","BOOTSTRAP_VUE_NO_WARN","from","isArray","arrayIncludes","concat","Array","toStr","prototype","toString","isCallable","fn","call","toInteger","value","number","Number","isNaN","isFinite","Math","floor","abs","maxSafeInteger","pow","toLength","min","max","arrayLike","C","this","items","TypeError","mapFn","arguments","length","T","len","kValue","A","k","find","defineProperty","predicate","o","thisArg","arg","array","indexOf","args","apply","addClass","removeClass","_env__WEBPACK_IMPORTED_MODULE_2__","passiveEventSupported","options","passive","addEventListener","removeEventListener","err","isElement","el","nodeType","Node","ELEMENT_NODE","className","classList","add","remove","cloneDeep","obj","defaultValue","reduce","result","val","object","key","[object Object]","clone_deep","get","path","join","hasOwnProperty","String","replace","steps","split","filter","every","step","utils_get","getComponentConfig","DEFAULTS","breakpoints","BAlert","dismissLabel","variant","BBadge","BButton","BButtonClose","textVariant","ariaLabel","BCardSubTitle","subTitleTextVariant","BCarousel","labelPrev","labelNext","labelGotoSlide","labelIndicators","BDropdown","toggleText","BFormFile","browseText","placeholder","dropPlaceholder","BFormText","BImg","blankColor","BImgLazy","BModal","cancelTitle","cancelVariant","okTitle","okVariant","headerCloseLabel","BNavbarToggle","label","CONFIG","getDefaults","getConfigValue","cmpName"],"mappings":"mHAAA,SAAAA,GAAAC,EAAAC,EAAAC,EAAA,sBAAAC,IAAAH,EAAAC,EAAAC,EAAA,sBAAAE,IAIO,MAAAD,EAAA,qBAAAE,UAAA,qBAAAC,OAWAF,GANPD,IAAA,iBAAAE,SAAAE,iBAAAC,UAAAC,gBAEON,GAAAO,QAAAJ,OAAAK,cAAAL,OAAAM,gBAIA,IACP,qBAAAb,MAA+Cc,OAAA,CAAAC,SAAA,aAAAC,SAAA,OAAeF,OAAA,CAAAC,SAAA,aAAAC,SAAA,MAAWC,mFChBzEhB,EAAAC,EAAAC,EAAA,sBAAAe,IAAAjB,EAAAC,EAAAC,EAAA,sBAAAgB,IAAAlB,EAAAC,EAAAC,EAAA,sBAAAiB,IAAAnB,EAAAC,EAAAC,EAAA,sBAAAkB,IAGAC,MAAAJ,OACAI,MAAAJ,KAAA,WACA,MAAAK,EAAAT,OAAAU,UAAAC,SACAC,EAAAC,GAAA,oBAAAA,GAAA,sBAAAJ,EAAAK,KAAAD,GACAE,EAAAC,IACA,MAAAC,EAAAC,OAAAF,GACA,OAAAG,MAAAF,GACA,EAEA,IAAAA,GAAAG,SAAAH,IAGAA,EAAA,QAAAI,KAAAC,MAAAD,KAAAE,IAAAN,IAFAA,GAIAO,EAAAH,KAAAI,IAAA,QACAC,EAAAV,GAAAK,KAAAM,IAAAN,KAAAO,IAAAb,EAAAC,GAAA,GAAAQ,GAGA,gBAAAK,GAEA,MAAAC,EAAAC,KAGAC,EAAAhC,OAAA6B,GAGA,SAAAA,EACA,UAAAI,UAAA,oEAIA,MAAAC,EAAAC,UAAAC,OAAA,EAAAD,UAAA,UACA,IAAAE,EAEA,wBAAAH,EAAA,CAGA,IAAAtB,EAAAsB,GACA,UAAAD,UAAA,qEAIAE,UAAAC,OAAA,IACAC,EAAAF,UAAA,IAMA,MAAAG,EAAAZ,EAAAM,EAAAI,QAMA,IAKAG,EALAC,EAAA5B,EAAAkB,GAAA9B,OAAA,IAAA8B,EAAAQ,IAAA,IAAA9B,MAAA8B,GAGAG,EAAA,EAGA,MAAAA,EAAAH,EACAC,EAAAP,EAAAS,GAEAD,EAAAC,GADAP,EACA,qBAAAG,EAAAH,EAAAK,EAAAE,GAAAP,EAAApB,KAAAuB,EAAAE,EAAAE,GAEAF,EAEAE,GAAA,EAKA,OAFAD,EAAAJ,OAAAE,EAEAE,GAxEA,IAgFAhC,MAAAE,UAAAgC,MAEA1C,OAAA2C,eAAAnC,MAAAE,UAAA,QACAM,MAAA,SAAA4B,GAEA,SAAAb,KACA,UAAAE,UAAA,iCAGA,MAAAY,EAAA7C,OAAA+B,MAGAO,EAAAO,EAAAT,SAAA,EAGA,uBAAAQ,EACA,UAAAX,UAAA,gCAIA,MAAAa,EAAAX,UAAA,GAGA,IAAAM,EAAA,EAGA,MAAAA,EAAAH,EAAA,CAKA,MAAAC,EAAAM,EAAAJ,GACA,GAAAG,EAAA9B,KAAAgC,EAAAP,EAAAE,EAAAI,GACA,OAAAN,EAGAE,QAUAjC,MAAAH,UACAG,MAAAH,QAAA0C,IAAA,mBAAA/C,OAAAU,UAAAC,SAAAG,KAAAiC,KAIO,MAAA3C,EAAAI,MAAAJ,KACAC,EAAAG,MAAAH,QAGAC,EAAA,CAAA0C,EAAAhC,KAAA,IAAAgC,EAAAC,QAAAjC,GACAT,EAAA,IAAA2C,IAAA1C,MAAAE,UAAAH,OAAA4C,MAAA,GAAAD,sCC5IP/D,EAAAC,EAAAC,EAAA,sBAAA+D,IAAAjE,EAAAC,EAAAC,EAAA,sBAAAgE,IAAAlE,EAAA,QAAAA,EAAA,YAAAmE,EAAAnE,EAAA,QAKA,IAAAoE,GAAA,EAEA,GAAID,EAAA,KACJ,IACA,MAAAE,EAAA,CACAC,cAGAF,GAAA,IAGA9D,OAAAiE,iBAAA,OAAAF,KACA/D,OAAAkE,oBAAA,OAAAH,KACG,MAAAI,GACHL,GAAA,EAKO,MA6BAM,EAAAC,IACP,OAAAjE,QAAAiE,KAAAC,WAAAC,KAAAC,eA4HOb,EAAA,CAAAU,EAAAI,KAIPA,GAAAL,EAAAC,MAAAK,WACAL,EAAAK,UAAAC,IAAAF,IAKOb,EAAA,CAAAS,EAAAI,KAIPA,GAAAL,EAAAC,MAAAK,WACAL,EAAAK,UAAAE,OAAAH,mEC9LO,MAAAI,EAAA,CAAAC,EAAAC,EAAAD,KACP,OAAMvE,OAAAgD,EAAA,KAAAhD,CAAOuE,GACbA,EAAAE,OAAA,CAAAC,EAAAC,IAAA,IAAAD,EAAAJ,EAAAK,MAAA,IAEM3E,OAAA4E,EAAA,KAAA5E,CAAauE,GACRvE,OAAA4E,EAAA,KAAA5E,CAAIuE,GAAAE,OACf,CAAAC,EAAAG,KAAA,IAAyBH,EAAAI,CAAAD,GAAAP,EAAAC,EAAAM,GAAAN,EAAAM,MACzB,IAGAL,GAGe,IAAAO,EAAA,ECHf,MAAAC,EAAA,CAAAT,EAAAU,EAAAT,EAAA,QAKA,GAHAS,EAASjF,OAAAgD,EAAA,KAAAhD,CAAOiF,KAAAC,KAAA,KAAAD,GAGhBA,IAAgBjF,OAAA4E,EAAA,KAAA5E,CAAQuE,GACxB,OAAAC,EAKA,GAAAD,EAAAY,eAAAF,GACA,OAAAV,EAAAU,GAIAA,EAAAG,OAAAH,GAAAI,QAAA,mBAEA,MAAAC,EAAAL,EAAAM,MAAA,KAAAC,OAAA3F,SAGA,WAAAyF,EAAAlD,OACAoC,EAIAc,EAAAG,MAAAC,GAA6B1F,OAAA4E,EAAA,KAAA5E,CAAQuE,MAAAY,eAAAO,IAAA,OAAAnB,IAAAmB,KACrCnB,EACAC,GAGe,IAAAmB,EAAA,YC5CfxG,EAAAC,EAAAC,EAAA,sBAAAuG,IAiCA,MAAAC,EAAA,CAEAC,YAAA,2BAIAC,OAAA,CACAC,aAAA,QACAC,QAAA,QAEAC,OAAA,CACAD,QAAA,aAEAE,QAAA,CACAF,QAAA,aAEAG,aAAA,CAEAC,YAAA,KACAC,UAAA,SAEAC,cAAA,CAEAC,oBAAA,SAEAC,UAAA,CACAC,UAAA,iBACAC,UAAA,aACAC,eAAA,aACAC,gBAAA,6BAEAC,UAAA,CACAC,WAAA,kBACAd,QAAA,aAEAe,UAAA,CACAC,WAAA,SAEAC,YAAA,iBACAC,gBAAA,mBAEAC,UAAA,CACAf,YAAA,SAEAgB,KAAA,CACAC,WAAA,eAEAC,SAAA,CACAD,WAAA,eAEAE,OAAA,CACAC,YAAA,SACAC,cAAA,YACAC,QAAA,KACAC,UAAA,UACAC,iBAAA,SAEAC,cAAA,CACAC,MAAA,sBAKA,IAAAC,EAAA,GAGA,MAAAC,EAAA,IAA0BlD,EAASc,GAqEnCqC,EAAArD,IAGA,OAASE,EAAUY,EAAGqC,EAAAnD,EAAcc,EAAGsC,IAAApD,MAKvCe,EAAA,CAAAuC,EAAAtD,EAAA,QAGA,OAAAA,EAAAqD,KAAiCC,KAAWtD,KAAIqD,EAAAC,IAAA","file":"js/about~2d898716.187e1a93.js","sourcesContent":["// Info about the current environment\n\n// Constants\n\nexport const inBrowser = typeof document !== 'undefined' && typeof window !== 'undefined'\n\nexport const isServer = !inBrowser\n\nexport const hasTouchSupport =\n  inBrowser && ('ontouchstart' in document.documentElement || navigator.maxTouchPoints > 0)\n\nexport const hasPointerEvent = inBrowser && Boolean(window.PointerEvent || window.MSPointerEvent)\n\n// Getters\n\nexport const getNoWarn = () =>\n  typeof process !== 'undefined' && process && process.env && process.env.BOOTSTRAP_VUE_NO_WARN\n","// Production steps of ECMA-262, Edition 6, 22.1.2.1\n// es6-ified by @alexsasharegan\n/* istanbul ignore if */\nif (!Array.from) {\n  Array.from = (function() {\n    const toStr = Object.prototype.toString\n    const isCallable = fn => typeof fn === 'function' || toStr.call(fn) === '[object Function]'\n    const toInteger = value => {\n      const number = Number(value)\n      if (isNaN(number)) {\n        return 0\n      }\n      if (number === 0 || !isFinite(number)) {\n        return number\n      }\n      return (number > 0 ? 1 : -1) * Math.floor(Math.abs(number))\n    }\n    const maxSafeInteger = Math.pow(2, 53) - 1\n    const toLength = value => Math.min(Math.max(toInteger(value), 0), maxSafeInteger)\n\n    // The length property of the from method is 1.\n    return function from(arrayLike /*, mapFn, thisArg */) {\n      // 1. Let C be the this value.\n      const C = this\n\n      // 2. Let items be ToObject(arrayLike).\n      const items = Object(arrayLike)\n\n      // 3. ReturnIfAbrupt(items).\n      if (arrayLike == null) {\n        throw new TypeError('Array.from requires an array-like object - not null or undefined')\n      }\n\n      // 4. If mapfn is undefined, then let mapping be false.\n      const mapFn = arguments.length > 1 ? arguments[1] : void undefined\n      let T\n\n      if (typeof mapFn !== 'undefined') {\n        // 5. else\n        // 5. a If IsCallable(mapfn) is false, throw a TypeError exception.\n        if (!isCallable(mapFn)) {\n          throw new TypeError('Array.from: when provided, the second argument must be a function')\n        }\n\n        // 5. b. If thisArg was supplied, let T be thisArg; else let T be undefined.\n        if (arguments.length > 2) {\n          T = arguments[2]\n        }\n      }\n\n      // 10. Let lenValue be Get(items, \"length\").\n      // 11. Let len be ToLength(lenValue).\n      const len = toLength(items.length)\n\n      // 13. If IsConstructor(C) is true, then\n      // 13. a. Let A be the result of calling the [[Construct]] internal method\n      // of C with an argument list containing the single item len.\n      // 14. a. Else, Let A be ArrayCreate(len).\n      let A = isCallable(C) ? Object(new C(len)) : new Array(len)\n\n      // 16. Let k be 0.\n      let k = 0\n      // 17. Repeat, while k < lenâ€¦ (also steps a - h)\n      let kValue\n      while (k < len) {\n        kValue = items[k]\n        if (mapFn) {\n          A[k] = typeof T === 'undefined' ? mapFn(kValue, k) : mapFn.call(T, kValue, k)\n        } else {\n          A[k] = kValue\n        }\n        k += 1\n      }\n      // 18. Let putStatus be Put(A, \"length\", len, true).\n      A.length = len\n      // 20. Return A.\n      return A\n    }\n  })()\n}\n\n// https://tc39.github.io/ecma262/#sec-array.prototype.find\n// Needed for IE support\n/* istanbul ignore if */\nif (!Array.prototype.find) {\n  // eslint-disable-next-line no-extend-native\n  Object.defineProperty(Array.prototype, 'find', {\n    value: function(predicate) {\n      // 1. Let O be ? ToObject(this value).\n      if (this == null) {\n        throw new TypeError('\"this\" is null or not defined')\n      }\n\n      const o = Object(this)\n\n      // 2. Let len be ? ToLength(? Get(O, \"length\")).\n      const len = o.length >>> 0\n\n      // 3. If IsCallable(predicate) is false, throw a TypeError exception.\n      if (typeof predicate !== 'function') {\n        throw new TypeError('predicate must be a function')\n      }\n\n      // 4. If thisArg was supplied, let T be thisArg; else let T be undefined.\n      const thisArg = arguments[1]\n\n      // 5. Let k be 0.\n      let k = 0\n\n      // 6. Repeat, while k < len\n      while (k < len) {\n        // a. Let Pk be ! ToString(k).\n        // b. Let kValue be ? Get(O, Pk).\n        // c. Let testResult be ToBoolean(? Call(predicate, T, Â« kValue, k, O Â»)).\n        // d. If testResult is true, return kValue.\n        const kValue = o[k]\n        if (predicate.call(thisArg, kValue, k, o)) {\n          return kValue\n        }\n        // e. Increase k by 1.\n        k++\n      }\n\n      // 7. Return undefined.\n      return undefined\n    }\n  })\n}\n\n/* istanbul ignore if */\nif (!Array.isArray) {\n  Array.isArray = arg => Object.prototype.toString.call(arg) === '[object Array]'\n}\n\n// Static\nexport const from = Array.from\nexport const isArray = Array.isArray\n\n// Instance\nexport const arrayIncludes = (array, value) => array.indexOf(value) !== -1\nexport const concat = (...args) => Array.prototype.concat.apply([], args)\n","import { from as arrayFrom } from './array'\nimport { isObject } from './object'\nimport { inBrowser } from './env'\n\n// Determine if the browser supports the option passive for events\nlet passiveEventSupported = false\n/* istanbul ignore if */\nif (inBrowser) {\n  try {\n    const options = {\n      get passive() {\n        // This function will be called when the browser\n        // attempts to access the passive property.\n        passiveEventSupported = true\n      }\n    }\n    window.addEventListener('test', options, options)\n    window.removeEventListener('test', options, options)\n  } catch (err) {\n    passiveEventSupported = false\n  }\n}\n\n// Exported only for testing purposes\nexport const isPassiveSupported = () => passiveEventSupported\n\n// Normalize event options based on support of passive option\n// Exported only for testing purposes\nexport const parseEventOptions = options => {\n  if (!passiveEventSupported) {\n    // Need to translate to actual Boolean value\n    return Boolean(isObject(options) ? options.useCapture : options)\n  }\n  /* istanbul ignore next: JSDOM doesn't support above detection of passive */\n  return options || { useCapture: false }\n  // So we can't reach this anymore for unit testing due to the above if statement\n}\n\n// Attach an event listener to an element\nexport const eventOn = (el, evtName, handler, options) => {\n  if (el && el.addEventListener) {\n    el.addEventListener(evtName, handler, parseEventOptions(options))\n  }\n}\n\n// Remove an event listener from an element\nexport const eventOff = (el, evtName, handler, options) => {\n  if (el && el.removeEventListener) {\n    el.removeEventListener(evtName, handler, parseEventOptions(options))\n  }\n}\n\n// Determine if an element is an HTML Element\nexport const isElement = el => {\n  return Boolean(el && el.nodeType === Node.ELEMENT_NODE)\n}\n\n// Determine if an HTML element is visible - Faster than CSS check\nexport const isVisible = el => {\n  if (!isElement(el) || !contains(document.body, el)) {\n    return false\n  }\n  if (el.style.display === 'none') {\n    // We do this check to help with vue-test-utils when using v-show\n    /* istanbul ignore next */\n    return false\n  }\n  // All browsers support getBoundingClientRect(), except JSDOM as it returns all 0's for values :(\n  // So any tests that need isVisible will fail in JSDOM\n  // Except when we override the getBCR prototype in some tests\n  const bcr = getBCR(el)\n  return Boolean(bcr && bcr.height > 0 && bcr.width > 0)\n}\n\n// Determine if an element is disabled\nexport const isDisabled = el => {\n  return (\n    !isElement(el) || el.disabled || hasClass(el, 'disabled') || Boolean(getAttr(el, 'disabled'))\n  )\n}\n\n// Cause/wait-for an element to reflow it's content (adjusting it's height/width)\nexport const reflow = el => {\n  // Requesting an elements offsetHight will trigger a reflow of the element content\n  /* istanbul ignore next: reflow doesn't happen in JSDOM */\n  return isElement(el) && el.offsetHeight\n}\n\n// Select all elements matching selector. Returns `[]` if none found\nexport const selectAll = (selector, root) => {\n  if (!isElement(root)) {\n    root = document\n  }\n  return arrayFrom(root.querySelectorAll(selector))\n}\n\n// Select a single element, returns `null` if not found\nexport const select = (selector, root) => {\n  if (!isElement(root)) {\n    root = document\n  }\n  return root.querySelector(selector) || null\n}\n\n// Determine if an element matches a selector\nexport const matches = (el, selector) => {\n  if (!isElement(el)) {\n    return false\n  }\n\n  // https://developer.mozilla.org/en-US/docs/Web/API/Element/matches#Polyfill\n  // Prefer native implementations over polyfill function\n  const proto = Element.prototype\n  /* istanbul ignore next */\n  const Matches =\n    proto.matches ||\n    proto.matchesSelector ||\n    proto.mozMatchesSelector ||\n    proto.msMatchesSelector ||\n    proto.oMatchesSelector ||\n    proto.webkitMatchesSelector ||\n    function(sel) /* istanbul ignore next */ {\n      const element = this\n      const m = selectAll(sel, element.document || element.ownerDocument)\n      let i = m.length\n      // eslint-disable-next-line no-empty\n      while (--i >= 0 && m.item(i) !== element) {}\n      return i > -1\n    }\n\n  return Matches.call(el, selector)\n}\n\n// Finds closest element matching selector. Returns `null` if not found\nexport const closest = (selector, root) => {\n  if (!isElement(root)) {\n    return null\n  }\n\n  // https://developer.mozilla.org/en-US/docs/Web/API/Element/closest\n  // Since we dont support IE < 10, we can use the \"Matches\" version of the polyfill for speed\n  // Prefer native implementation over polyfill function\n  const Closest =\n    Element.prototype.closest ||\n    function(sel) /* istanbul ignore next */ {\n      let element = this\n      if (!contains(document.documentElement, element)) {\n        return null\n      }\n      do {\n        // Use our \"patched\" matches function\n        if (matches(element, sel)) {\n          return element\n        }\n        element = element.parentElement || element.parentNode\n      } while (element !== null && element.nodeType === Node.ELEMENT_NODE)\n      return null\n    }\n\n  const el = Closest.call(root, selector)\n  // Emulate jQuery closest and return `null` if match is the passed in element (root)\n  return el === root ? null : el\n}\n\n// Returns true if the parent element contains the child element\nexport const contains = (parent, child) => {\n  if (!parent || typeof parent.contains !== 'function') {\n    return false\n  }\n  return parent.contains(child)\n}\n\n// Get an element given an ID\nexport const getById = id => {\n  return document.getElementById(/^#/.test(id) ? id.slice(1) : id) || null\n}\n\n// Add a class to an element\nexport const addClass = (el, className) => {\n  // We are checking for `el.classList` existence here since IE 11\n  // returns `undefined` for some elements (e.g. SVG elements)\n  // See https://github.com/bootstrap-vue/bootstrap-vue/issues/2713\n  if (className && isElement(el) && el.classList) {\n    el.classList.add(className)\n  }\n}\n\n// Remove a class from an element\nexport const removeClass = (el, className) => {\n  // We are checking for `el.classList` existence here since IE 11\n  // returns `undefined` for some elements (e.g. SVG elements)\n  // See https://github.com/bootstrap-vue/bootstrap-vue/issues/2713\n  if (className && isElement(el) && el.classList) {\n    el.classList.remove(className)\n  }\n}\n\n// Test if an element has a class\nexport const hasClass = (el, className) => {\n  // We are checking for `el.classList` existence here since IE 11\n  // returns `undefined` for some elements (e.g. SVG elements)\n  // See https://github.com/bootstrap-vue/bootstrap-vue/issues/2713\n  if (className && isElement(el) && el.classList) {\n    return el.classList.contains(className)\n  }\n  return false\n}\n\n// Set an attribute on an element\nexport const setAttr = (el, attr, value) => {\n  if (attr && isElement(el)) {\n    el.setAttribute(attr, value)\n  }\n}\n\n// Remove an attribute from an element\nexport const removeAttr = (el, attr) => {\n  if (attr && isElement(el)) {\n    el.removeAttribute(attr)\n  }\n}\n\n// Get an attribute value from an element (returns `null` if not found)\nexport const getAttr = (el, attr) => {\n  if (attr && isElement(el)) {\n    return el.getAttribute(attr)\n  }\n  return null\n}\n\n// Determine if an attribute exists on an element (returns `true`\n// or `false`, or `null` if element not found)\nexport const hasAttr = (el, attr) => {\n  if (attr && isElement(el)) {\n    return el.hasAttribute(attr)\n  }\n  return null\n}\n\n// Return the Bounding Client Rect of an element. Returns `null` if not an element\nexport const getBCR = el => {\n  /* istanbul ignore next: getBoundingClientRect() doesn't work in JSDOM */\n  return isElement(el) ? el.getBoundingClientRect() : null\n}\n\n// Get computed style object for an element\nexport const getCS = el => {\n  /* istanbul ignore next: getComputedStyle() doesn't work in JSDOM */\n  return isElement(el) ? window.getComputedStyle(el) : {}\n}\n\n// Return an element's offset with respect to document element\n// https://j11y.io/jquery/#v=git&fn=jQuery.fn.offset\nexport const offset = el => /* istanbul ignore next: getBoundingClientRect(), getClientRects() doesn't work in JSDOM */ {\n  let _offset = { top: 0, left: 0 }\n  if (!isElement(el) || el.getClientRects().length === 0) {\n    return _offset\n  }\n  const bcr = getBCR(el)\n  if (bcr) {\n    const win = el.ownerDocument.defaultView\n    _offset.top = bcr.top + win.pageYOffset\n    _offset.left = bcr.left + win.pageXOffset\n  }\n  return _offset\n}\n\n// Return an element's offset with respect to to it's offsetParent\n// https://j11y.io/jquery/#v=git&fn=jQuery.fn.position\nexport const position = el => /* istanbul ignore next: getBoundingClientRect() doesn't work in JSDOM */ {\n  let _offset = { top: 0, left: 0 }\n  if (!isElement(el)) {\n    return _offset\n  }\n  let parentOffset = { top: 0, left: 0 }\n  const elStyles = getCS(el)\n  if (elStyles.position === 'fixed') {\n    _offset = getBCR(el) || _offset\n  } else {\n    _offset = offset(el)\n    const doc = el.ownerDocument\n    let offsetParent = el.offsetParent || doc.documentElement\n    while (\n      offsetParent &&\n      (offsetParent === doc.body || offsetParent === doc.documentElement) &&\n      getCS(offsetParent).position === 'static'\n    ) {\n      offsetParent = offsetParent.parentNode\n    }\n    if (offsetParent && offsetParent !== el && offsetParent.nodeType === Node.ELEMENT_NODE) {\n      parentOffset = offset(offsetParent)\n      const offsetParentStyles = getCS(offsetParent)\n      parentOffset.top += parseFloat(offsetParentStyles.borderTopWidth)\n      parentOffset.left += parseFloat(offsetParentStyles.borderLeftWidth)\n    }\n  }\n  return {\n    top: _offset.top - parentOffset.top - parseFloat(elStyles.marginTop),\n    left: _offset.left - parentOffset.left - parseFloat(elStyles.marginLeft)\n  }\n}\n\n// requestAnimationFrame convenience method\n// We don't have a version for cancelAnimationFrame, but we don't call it anywhere\nexport const requestAF = cb => {\n  const w = inBrowser ? window : {}\n  const rAF =\n    w.requestAnimationFrame ||\n    w.webkitRequestAnimationFrame ||\n    w.mozRequestAnimationFrame ||\n    w.msRequestAnimationFrame ||\n    w.oRequestAnimationFrame ||\n    (cb => {\n      // Fallback, but not a true polyfill.\n      // But all browsers we support (other than Opera Mini) support rAF\n      // without a polyfill.\n      /* istanbul ignore next */\n      return setTimeout(cb, 16)\n    })\n  return rAF(cb)\n}\n","import { isArray } from './array'\nimport { isPlainObject, keys } from './object'\n\nexport const cloneDeep = (obj, defaultValue = obj) => {\n  if (isArray(obj)) {\n    return obj.reduce((result, val) => [...result, cloneDeep(val, val)], [])\n  }\n  if (isPlainObject(obj)) {\n    return keys(obj).reduce(\n      (result, key) => ({ ...result, [key]: cloneDeep(obj[key], obj[key]) }),\n      {}\n    )\n  }\n  return defaultValue\n}\n\nexport default cloneDeep\n","import { isArray } from './array'\nimport { isObject } from './object'\n\n/**\n * Get property defined by dot/array notation in string.\n *\n * @link https://gist.github.com/jeneg/9767afdcca45601ea44930ea03e0febf#gistcomment-1935901\n *\n * @param {Object} obj\n * @param {string|Array} path\n * @param {*} defaultValue (optional)\n * @return {*}\n */\nconst get = (obj, path, defaultValue = null) => {\n  // Handle array of path values\n  path = isArray(path) ? path.join('.') : path\n\n  // If no path or no object passed\n  if (!path || !isObject(obj)) {\n    return defaultValue\n  }\n\n  // Handle edge case where user has dot(s) in top-level item field key\n  // See https://github.com/bootstrap-vue/bootstrap-vue/issues/2762\n  if (obj.hasOwnProperty(path)) {\n    return obj[path]\n  }\n\n  // Handle string array notation (numeric indices only)\n  path = String(path).replace(/\\[(\\d+)]/g, '.$1')\n\n  const steps = path.split('.').filter(Boolean)\n\n  // Handle case where someone passes a string of only dots\n  if (steps.length === 0) {\n    return defaultValue\n  }\n\n  // Traverse path in object to find result\n  return steps.every(step => isObject(obj) && obj.hasOwnProperty(step) && (obj = obj[step]) != null)\n    ? obj\n    : defaultValue\n}\n\nexport default get\n","import cloneDeep from './clone-deep'\nimport get from './get'\nimport warn from './warn'\nimport { isArray } from './array'\nimport { keys, isObject } from './object'\n\n// General Bootstrap Vue configuration\n//\n// BREAKPOINT DEFINITIONS\n//\n// Some components (BCol and BFormGroup) generate props based on breakpoints, and this\n// occurs when the component is first loaded (evaluated), which may happen before the\n// config is created/modified\n//\n// To get around this we make these components async (lazy evaluation)\n// The component definition is only called/executed when the first access to the\n// component is used (and cached on subsequent uses)\n//\n// See: https://vuejs.org/v2/guide/components-dynamic-async.html#Async-Components\n//\n// PROP DEFAULTS\n//\n// For default values on props, we use the default value factory function approach so\n// so that the default values are pulled in at each component instantiation\n//\n//  props: {\n//    variant: {\n//      type: String,\n//      default: () => getConfigComponent('BAlert', 'variant')\n//    }\n//  }\n\n// prettier-ignore\nconst DEFAULTS = {\n  // Breakpoints\n  breakpoints: ['xs', 'sm', 'md', 'lg', 'xl'],\n\n  // Component Specific defaults are keyed by the component\n  // name (PascalCase) and prop name (camelCase)\n  BAlert: {\n    dismissLabel: 'Close',\n    variant: 'info'\n  },\n  BBadge: {\n    variant: 'secondary'\n  },\n  BButton: {\n    variant: 'secondary'\n  },\n  BButtonClose: {\n    // `textVariant` is `null` to inherit the current text color\n    textVariant: null,\n    ariaLabel: 'Close'\n  },\n  BCardSubTitle: {\n    // BCard and BCardBody also inherit this prop\n    subTitleTextVariant: 'muted'\n  },\n  BCarousel: {\n    labelPrev: 'Previous Slide',\n    labelNext: 'Next Slide',\n    labelGotoSlide: 'Goto Slide',\n    labelIndicators: 'Select a slide to display'\n  },\n  BDropdown: {\n    toggleText: 'Toggle Dropdown',\n    variant: 'secondary'\n  },\n  BFormFile: {\n    browseText: 'Browse',\n    // Chrome default file prompt\n    placeholder: 'No file chosen',\n    dropPlaceholder: 'Drop files here'\n  },\n  BFormText: {\n    textVariant: 'muted'\n  },\n  BImg: {\n    blankColor: 'transparent'\n  },\n  BImgLazy: {\n    blankColor: 'transparent'\n  },\n  BModal: {\n    cancelTitle: 'Cancel',\n    cancelVariant: 'secondary',\n    okTitle: 'OK',\n    okVariant: 'primary',\n    headerCloseLabel: 'Close'\n  },\n  BNavbarToggle: {\n    label: 'Toggle navigation'\n  }\n}\n\n// This contains user defined configuration\nlet CONFIG = {}\n\n// Method to get a deep clone (immutable) copy of the defaults\nconst getDefaults = () => cloneDeep(DEFAULTS)\n\n// Method to set the config\n// Merges in only known top-level and sub-level keys\n//   Vue.use(BootstrapVue, config)\n// or\n//   BootstrapVue.setConfig(config)\n//   Vue.use(BootstrapVue)\n\nconst setConfig = (config = {}) => {\n  if (!isObject(config)) {\n    /* istanbul ignore next */\n    return\n  }\n\n  keys(config)\n    .filter(cmpName => config.hasOwnProperty(cmpName))\n    .forEach(cmpName => {\n      if (!DEFAULTS.hasOwnProperty(cmpName)) {\n        /* istanbul ignore next */\n        warn(`config: unknown config property \"${cmpName}\"`)\n        /* istanbul ignore next */\n        return\n      }\n      const cmpConfig = config[cmpName]\n      if (cmpName === 'breakpoints') {\n        // Special case for breakpoints\n        const breakpoints = config.breakpoints\n        if (\n          !isArray(breakpoints) ||\n          breakpoints.length < 2 ||\n          breakpoints.some(b => typeof b !== 'string' || b.length === 0)\n        ) {\n          /* istanbul ignore next */\n          warn('config: \"breakpoints\" must be an array of at least 2 breakpoint names')\n        } else {\n          CONFIG.breakpoints = cloneDeep(breakpoints)\n        }\n      } else if (isObject(cmpConfig)) {\n        keys(cmpConfig)\n          .filter(key => cmpConfig.hasOwnProperty(key))\n          .forEach(key => {\n            if (!DEFAULTS[cmpName].hasOwnProperty(key)) {\n              /* istanbul ignore next */\n              warn(`config: unknown config property \"${cmpName}.{$key}\"`)\n            } else {\n              // If we pre-populate the config with defaults, we can skip this line\n              CONFIG[cmpName] = CONFIG[cmpName] || {}\n              if (cmpConfig[key] !== undefined) {\n                CONFIG[cmpName][key] = cloneDeep(cmpConfig[key])\n              }\n            }\n          })\n      }\n    })\n}\n\n// Reset the user config to default\n// For testing purposes only\nconst resetConfig = () => {\n  CONFIG = {}\n}\n\n// Get the current user config\n// For testing purposes only\nconst getConfig = () => cloneDeep(CONFIG)\n\n// Method to grab a config value based on a dotted/array notation key\n// Returns a deep clone (immutable) copy\nconst getConfigValue = key => {\n  // First we try the user config, and if key not found we fall back to default value\n  // NOTE: If we deep clone DEFAULTS into config, then we can skip the fallback for get\n  return cloneDeep(get(CONFIG, key, get(getDefaults(), key)))\n}\n\n// Method to grab a config value for a particular component.\n// Returns a deep clone (immutable) copy\nconst getComponentConfig = (cmpName, key = null) => {\n  // Return the particular config value for key for if specified,\n  // otherwise we return the full config\n  return key ? getConfigValue(`${cmpName}.${key}`) : getConfigValue(cmpName) || {}\n}\n\n// Convenience method for getting all breakpoint names\nconst getBreakpoints = () => getConfigValue('breakpoints')\n\n// Convenience method for getting breakpoints with\n// the smallest breakpoint set as ''\n// Useful for components that create breakpoint specific props\nconst getBreakpointsUp = () => {\n  const breakpoints = getBreakpoints()\n  breakpoints[0] = ''\n  return breakpoints\n}\n\n// Convenience method for getting breakpoints with\n// the largest breakpoint set as ''\n// Useful for components that create breakpoint specific props\nconst getBreakpointsDown = () => {\n  const breakpoints = getBreakpoints()\n  breakpoints[breakpoints.length - 1] = ''\n  return breakpoints\n}\n\n// Named Exports\nexport {\n  setConfig,\n  resetConfig,\n  getConfig,\n  getDefaults,\n  getConfigValue,\n  getComponentConfig,\n  getBreakpoints,\n  getBreakpointsUp,\n  getBreakpointsDown\n}\n"],"sourceRoot":""}