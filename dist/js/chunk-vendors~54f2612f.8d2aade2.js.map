{"version":3,"sources":["webpack:///./src/node_modules/socket.io-parser/index.js","webpack:///./src/node_modules/socket.io-parser/binary.js"],"names":["debug","__webpack_require__","Emitter","binary","isArray","isBuf","Encoder","exports","protocol","types","CONNECT","DISCONNECT","EVENT","ACK","ERROR","BINARY_EVENT","BINARY_ACK","Decoder","ERROR_PACKET","encodeAsString","obj","str","type","attachments","nsp","id","data","payload","tryStringify","JSON","stringify","e","encodeAsBinary","callback","writeEncoding","bloblessData","deconstruction","deconstructPacket","pack","packet","buffers","unshift","removeBlobs","this","reconstructor","decodeString","i","p","Number","charAt","error","buf","length","Error","c","next","tryParse","substr","isPayloadValid","parse","BinaryReconstructor","reconPack","msg","prototype","encode","encoding","add","emit","base64","takeBinaryData","destroy","finishedReconstruction","binData","push","reconstructPacket","toString","Object","withNativeBlob","Blob","call","withNativeFile","File","_deconstructPacket","placeholder","_placeholder","num","newData","Array","Date","key","_reconstructPacket","packetData","undefined","_removeBlobs","curKey","containingObject","pendingBlobs","fileReader","FileReader","onload","result","readAsArrayBuffer"],"mappings":"6GAKA,IAAAA,EAAYC,EAAQ,QAARA,CAAe,oBAC3BC,EAAcD,EAAQ,QACtBE,EAAaF,EAAQ,QACrBG,EAAcH,EAAQ,QACtBI,EAAYJ,EAAQ,QAwGpB,SAAAK,KAhGAC,EAAAC,SAAA,EAQAD,EAAAE,MAAA,CACA,UACA,aACA,QACA,MACA,QACA,eACA,cASAF,EAAAG,QAAA,EAQAH,EAAAI,WAAA,EAQAJ,EAAAK,MAAA,EAQAL,EAAAM,IAAA,EAQAN,EAAAO,MAAA,EAQAP,EAAAQ,aAAA,EAQAR,EAAAS,WAAA,EAQAT,EAAAD,UAQAC,EAAAU,UAUA,IAAAC,EAAAX,EAAAO,MAAA,iBA+BA,SAAAK,EAAAC,GAGA,IAAAC,EAAA,GAAAD,EAAAE,KAmBA,GAhBAf,EAAAQ,eAAAK,EAAAE,MAAAf,EAAAS,aAAAI,EAAAE,OACAD,GAAAD,EAAAG,YAAA,KAKAH,EAAAI,KAAA,MAAAJ,EAAAI,MACAH,GAAAD,EAAAI,IAAA,KAIA,MAAAJ,EAAAK,KACAJ,GAAAD,EAAAK,IAIA,MAAAL,EAAAM,KAAA,CACA,IAAAC,EAAAC,EAAAR,EAAAM,MACA,QAAAC,EAGA,OAAAT,EAFAG,GAAAM,EAOA,OADA3B,EAAA,mBAAAoB,EAAAC,GACAA,EAGA,SAAAO,EAAAP,GACA,IACA,OAAAQ,KAAAC,UAAAT,GACG,MAAAU,GACH,UAcA,SAAAC,EAAAZ,EAAAa,GAEA,SAAAC,EAAAC,GACA,IAAAC,EAAAjC,EAAAkC,kBAAAF,GACAG,EAAAnB,EAAAiB,EAAAG,QACAC,EAAAJ,EAAAI,QAEAA,EAAAC,QAAAH,GACAL,EAAAO,GAGArC,EAAAuC,YAAAtB,EAAAc,GAUA,SAAAjB,IACA0B,KAAAC,cAAA,KAsDA,SAAAC,EAAAxB,GACA,IAAAyB,EAAA,EAEAC,EAAA,CACAzB,KAAA0B,OAAA3B,EAAA4B,OAAA,KAGA,SAAA1C,EAAAE,MAAAsC,EAAAzB,MACA,OAAA4B,EAAA,uBAAAH,EAAAzB,MAIA,GAAAf,EAAAQ,eAAAgC,EAAAzB,MAAAf,EAAAS,aAAA+B,EAAAzB,KAAA,CACA,IAAA6B,EAAA,GACA,YAAA9B,EAAA4B,SAAAH,GAEA,GADAK,GAAA9B,EAAA4B,OAAAH,GACAA,GAAAzB,EAAA+B,OAAA,MAEA,GAAAD,GAAAH,OAAAG,IAAA,MAAA9B,EAAA4B,OAAAH,GACA,UAAAO,MAAA,uBAEAN,EAAAxB,YAAAyB,OAAAG,GAIA,SAAA9B,EAAA4B,OAAAH,EAAA,IACAC,EAAAvB,IAAA,GACA,QAAAsB,EAAA,CACA,IAAAQ,EAAAjC,EAAA4B,OAAAH,GACA,SAAAQ,EAAA,MAEA,GADAP,EAAAvB,KAAA8B,EACAR,IAAAzB,EAAA+B,OAAA,YAGAL,EAAAvB,IAAA,IAIA,IAAA+B,EAAAlC,EAAA4B,OAAAH,EAAA,GACA,QAAAS,GAAAP,OAAAO,MAAA,CACAR,EAAAtB,GAAA,GACA,QAAAqB,EAAA,CACAQ,EAAAjC,EAAA4B,OAAAH,GACA,SAAAQ,GAAAN,OAAAM,MAAA,GACAR,EACA,MAGA,GADAC,EAAAtB,IAAAJ,EAAA4B,OAAAH,GACAA,IAAAzB,EAAA+B,OAAA,MAEAL,EAAAtB,GAAAuB,OAAAD,EAAAtB,IAIA,GAAAJ,EAAA4B,SAAAH,GAAA,CACA,IAAAnB,EAAA6B,EAAAnC,EAAAoC,OAAAX,IACAY,GAAA,IAAA/B,IAAAoB,EAAAzB,OAAAf,EAAAO,OAAAV,EAAAuB,IACA,IAAA+B,EAGA,OAAAR,EAAA,mBAFAH,EAAArB,KAAAC,EAOA,OADA3B,EAAA,mBAAAqB,EAAA0B,GACAA,EAGA,SAAAS,EAAAnC,GACA,IACA,OAAAQ,KAAA8B,MAAAtC,GACG,MAAAU,GACH,UA0BA,SAAA6B,EAAArB,GACAI,KAAAkB,UAAAtB,EACAI,KAAAH,QAAA,GAkCA,SAAAU,EAAAY,GACA,OACAxC,KAAAf,EAAAO,MACAY,KAAA,iBAAAoC,GA7RAxD,EAAAyD,UAAAC,OAAA,SAAA5C,EAAAa,GAGA,GAFAjC,EAAA,qBAAAoB,GAEAb,EAAAQ,eAAAK,EAAAE,MAAAf,EAAAS,aAAAI,EAAAE,KACAU,EAAAZ,EAAAa,OACG,CACH,IAAAgC,EAAA9C,EAAAC,GACAa,EAAA,CAAAgC,MA8FA/D,EAAAe,EAAA8C,WAUA9C,EAAA8C,UAAAG,IAAA,SAAA9C,GACA,IAAAmB,EACA,qBAAAnB,EACAmB,EAAAM,EAAAzB,GACAb,EAAAQ,eAAAwB,EAAAjB,MAAAf,EAAAS,aAAAuB,EAAAjB,MACAqB,KAAAC,cAAA,IAAAgB,EAAArB,GAGA,IAAAI,KAAAC,cAAAiB,UAAAtC,aACAoB,KAAAwB,KAAA,UAAA5B,IAGAI,KAAAwB,KAAA,UAAA5B,OAEG,KAAAlC,EAAAe,OAAAgD,OAWH,UAAAf,MAAA,iBAAAjC,GAVA,IAAAuB,KAAAC,cACA,UAAAS,MAAA,oDAEAd,EAAAI,KAAAC,cAAAyB,eAAAjD,GACAmB,IACAI,KAAAC,cAAA,KACAD,KAAAwB,KAAA,UAAA5B,MAkGAtB,EAAA8C,UAAAO,QAAA,WACA3B,KAAAC,eACAD,KAAAC,cAAA2B,0BA6BAX,EAAAG,UAAAM,eAAA,SAAAG,GAEA,GADA7B,KAAAH,QAAAiC,KAAAD,GACA7B,KAAAH,QAAAY,SAAAT,KAAAkB,UAAAtC,YAAA,CACA,IAAAgB,EAAApC,EAAAuE,kBAAA/B,KAAAkB,UAAAlB,KAAAH,SAEA,OADAG,KAAA4B,yBACAhC,EAEA,aASAqB,EAAAG,UAAAQ,uBAAA,WACA5B,KAAAkB,UAAA,KACAlB,KAAAH,QAAA,0BChZA,IAAApC,EAAcH,EAAQ,QACtBI,EAAYJ,EAAQ,QACpB0E,EAAAC,OAAAb,UAAAY,SACAE,EAAA,oBAAAC,MAAA,qBAAAA,MAAA,6BAAAH,EAAAI,KAAAD,MACAE,EAAA,oBAAAC,MAAA,qBAAAA,MAAA,6BAAAN,EAAAI,KAAAE,MAqBA,SAAAC,EAAAxD,EAAAc,GACA,IAAAd,EAAA,OAAAA,EAEA,GAAArB,EAAAqB,GAAA,CACA,IAAAyD,EAAA,CAAuBC,cAAA,EAAAC,IAAA7C,EAAAY,QAEvB,OADAZ,EAAAiC,KAAA/C,GACAyD,EACG,GAAA/E,EAAAsB,GAAA,CAEH,IADA,IAAA4D,EAAA,IAAAC,MAAA7D,EAAA0B,QACAN,EAAA,EAAmBA,EAAApB,EAAA0B,OAAiBN,IACpCwC,EAAAxC,GAAAoC,EAAAxD,EAAAoB,GAAAN,GAEA,OAAA8C,EACG,qBAAA5D,kBAAA8D,MAAA,CACHF,EAAA,GACA,QAAAG,KAAA/D,EACA4D,EAAAG,GAAAP,EAAAxD,EAAA+D,GAAAjD,GAEA,OAAA8C,EAEA,OAAA5D,EAkBA,SAAAgE,EAAAhE,EAAAc,GACA,IAAAd,EAAA,OAAAA,EAEA,GAAAA,KAAA0D,aACA,OAAA5C,EAAAd,EAAA2D,KACG,GAAAjF,EAAAsB,GACH,QAAAoB,EAAA,EAAmBA,EAAApB,EAAA0B,OAAiBN,IACpCpB,EAAAoB,GAAA4C,EAAAhE,EAAAoB,GAAAN,QAEG,qBAAAd,EACH,QAAA+D,KAAA/D,EACAA,EAAA+D,GAAAC,EAAAhE,EAAA+D,GAAAjD,GAIA,OAAAd,EA9DAnB,EAAA8B,kBAAA,SAAAE,GACA,IAAAC,EAAA,GACAmD,EAAApD,EAAAb,KACAY,EAAAC,EAGA,OAFAD,EAAAZ,KAAAwD,EAAAS,EAAAnD,GACAF,EAAAf,YAAAiB,EAAAY,OACA,CAAUb,OAAAD,EAAAE,YAmCVjC,EAAAmE,kBAAA,SAAAnC,EAAAC,GAGA,OAFAD,EAAAb,KAAAgE,EAAAnD,EAAAb,KAAAc,GACAD,EAAAhB,iBAAAqE,EACArD,GA+BAhC,EAAAmC,YAAA,SAAAhB,EAAAO,GACA,SAAA4D,EAAAzE,EAAA0E,EAAAC,GACA,IAAA3E,EAAA,OAAAA,EAGA,GAAAyD,GAAAzD,aAAA0D,MACAE,GAAA5D,aAAA6D,KAAA,CACAe,IAGA,IAAAC,EAAA,IAAAC,WACAD,EAAAE,OAAA,WACAJ,EACAA,EAAAD,GAAAnD,KAAAyD,OAGAjE,EAAAQ,KAAAyD,SAIAJ,GACA/D,EAAAE,IAIA8D,EAAAI,kBAAAjF,QACK,GAAAhB,EAAAgB,GACL,QAAA0B,EAAA,EAAqBA,EAAA1B,EAAAgC,OAAgBN,IACrC+C,EAAAzE,EAAA0B,KAAA1B,QAEK,qBAAAA,IAAAf,EAAAe,GACL,QAAAqE,KAAArE,EACAyE,EAAAzE,EAAAqE,KAAArE,GAKA,IAAA4E,EAAA,EACA7D,EAAAT,EACAmE,EAAA1D,GACA6D,GACA/D,EAAAE","file":"js/chunk-vendors~54f2612f.8d2aade2.js","sourcesContent":["\n/**\n * Module dependencies.\n */\n\nvar debug = require('debug')('socket.io-parser');\nvar Emitter = require('component-emitter');\nvar binary = require('./binary');\nvar isArray = require('isarray');\nvar isBuf = require('./is-buffer');\n\n/**\n * Protocol version.\n *\n * @api public\n */\n\nexports.protocol = 4;\n\n/**\n * Packet types.\n *\n * @api public\n */\n\nexports.types = [\n  'CONNECT',\n  'DISCONNECT',\n  'EVENT',\n  'ACK',\n  'ERROR',\n  'BINARY_EVENT',\n  'BINARY_ACK'\n];\n\n/**\n * Packet type `connect`.\n *\n * @api public\n */\n\nexports.CONNECT = 0;\n\n/**\n * Packet type `disconnect`.\n *\n * @api public\n */\n\nexports.DISCONNECT = 1;\n\n/**\n * Packet type `event`.\n *\n * @api public\n */\n\nexports.EVENT = 2;\n\n/**\n * Packet type `ack`.\n *\n * @api public\n */\n\nexports.ACK = 3;\n\n/**\n * Packet type `error`.\n *\n * @api public\n */\n\nexports.ERROR = 4;\n\n/**\n * Packet type 'binary event'\n *\n * @api public\n */\n\nexports.BINARY_EVENT = 5;\n\n/**\n * Packet type `binary ack`. For acks with binary arguments.\n *\n * @api public\n */\n\nexports.BINARY_ACK = 6;\n\n/**\n * Encoder constructor.\n *\n * @api public\n */\n\nexports.Encoder = Encoder;\n\n/**\n * Decoder constructor.\n *\n * @api public\n */\n\nexports.Decoder = Decoder;\n\n/**\n * A socket.io Encoder instance\n *\n * @api public\n */\n\nfunction Encoder() {}\n\nvar ERROR_PACKET = exports.ERROR + '\"encode error\"';\n\n/**\n * Encode a packet as a single string if non-binary, or as a\n * buffer sequence, depending on packet type.\n *\n * @param {Object} obj - packet object\n * @param {Function} callback - function to handle encodings (likely engine.write)\n * @return Calls callback with Array of encodings\n * @api public\n */\n\nEncoder.prototype.encode = function(obj, callback){\n  debug('encoding packet %j', obj);\n\n  if (exports.BINARY_EVENT === obj.type || exports.BINARY_ACK === obj.type) {\n    encodeAsBinary(obj, callback);\n  } else {\n    var encoding = encodeAsString(obj);\n    callback([encoding]);\n  }\n};\n\n/**\n * Encode packet as string.\n *\n * @param {Object} packet\n * @return {String} encoded\n * @api private\n */\n\nfunction encodeAsString(obj) {\n\n  // first is type\n  var str = '' + obj.type;\n\n  // attachments if we have them\n  if (exports.BINARY_EVENT === obj.type || exports.BINARY_ACK === obj.type) {\n    str += obj.attachments + '-';\n  }\n\n  // if we have a namespace other than `/`\n  // we append it followed by a comma `,`\n  if (obj.nsp && '/' !== obj.nsp) {\n    str += obj.nsp + ',';\n  }\n\n  // immediately followed by the id\n  if (null != obj.id) {\n    str += obj.id;\n  }\n\n  // json data\n  if (null != obj.data) {\n    var payload = tryStringify(obj.data);\n    if (payload !== false) {\n      str += payload;\n    } else {\n      return ERROR_PACKET;\n    }\n  }\n\n  debug('encoded %j as %s', obj, str);\n  return str;\n}\n\nfunction tryStringify(str) {\n  try {\n    return JSON.stringify(str);\n  } catch(e){\n    return false;\n  }\n}\n\n/**\n * Encode packet as 'buffer sequence' by removing blobs, and\n * deconstructing packet into object with placeholders and\n * a list of buffers.\n *\n * @param {Object} packet\n * @return {Buffer} encoded\n * @api private\n */\n\nfunction encodeAsBinary(obj, callback) {\n\n  function writeEncoding(bloblessData) {\n    var deconstruction = binary.deconstructPacket(bloblessData);\n    var pack = encodeAsString(deconstruction.packet);\n    var buffers = deconstruction.buffers;\n\n    buffers.unshift(pack); // add packet info to beginning of data list\n    callback(buffers); // write all the buffers\n  }\n\n  binary.removeBlobs(obj, writeEncoding);\n}\n\n/**\n * A socket.io Decoder instance\n *\n * @return {Object} decoder\n * @api public\n */\n\nfunction Decoder() {\n  this.reconstructor = null;\n}\n\n/**\n * Mix in `Emitter` with Decoder.\n */\n\nEmitter(Decoder.prototype);\n\n/**\n * Decodes an encoded packet string into packet JSON.\n *\n * @param {String} obj - encoded packet\n * @return {Object} packet\n * @api public\n */\n\nDecoder.prototype.add = function(obj) {\n  var packet;\n  if (typeof obj === 'string') {\n    packet = decodeString(obj);\n    if (exports.BINARY_EVENT === packet.type || exports.BINARY_ACK === packet.type) { // binary packet's json\n      this.reconstructor = new BinaryReconstructor(packet);\n\n      // no attachments, labeled binary but no binary data to follow\n      if (this.reconstructor.reconPack.attachments === 0) {\n        this.emit('decoded', packet);\n      }\n    } else { // non-binary full packet\n      this.emit('decoded', packet);\n    }\n  } else if (isBuf(obj) || obj.base64) { // raw binary data\n    if (!this.reconstructor) {\n      throw new Error('got binary data when not reconstructing a packet');\n    } else {\n      packet = this.reconstructor.takeBinaryData(obj);\n      if (packet) { // received final buffer\n        this.reconstructor = null;\n        this.emit('decoded', packet);\n      }\n    }\n  } else {\n    throw new Error('Unknown type: ' + obj);\n  }\n};\n\n/**\n * Decode a packet String (JSON data)\n *\n * @param {String} str\n * @return {Object} packet\n * @api private\n */\n\nfunction decodeString(str) {\n  var i = 0;\n  // look up type\n  var p = {\n    type: Number(str.charAt(0))\n  };\n\n  if (null == exports.types[p.type]) {\n    return error('unknown packet type ' + p.type);\n  }\n\n  // look up attachments if type binary\n  if (exports.BINARY_EVENT === p.type || exports.BINARY_ACK === p.type) {\n    var buf = '';\n    while (str.charAt(++i) !== '-') {\n      buf += str.charAt(i);\n      if (i == str.length) break;\n    }\n    if (buf != Number(buf) || str.charAt(i) !== '-') {\n      throw new Error('Illegal attachments');\n    }\n    p.attachments = Number(buf);\n  }\n\n  // look up namespace (if any)\n  if ('/' === str.charAt(i + 1)) {\n    p.nsp = '';\n    while (++i) {\n      var c = str.charAt(i);\n      if (',' === c) break;\n      p.nsp += c;\n      if (i === str.length) break;\n    }\n  } else {\n    p.nsp = '/';\n  }\n\n  // look up id\n  var next = str.charAt(i + 1);\n  if ('' !== next && Number(next) == next) {\n    p.id = '';\n    while (++i) {\n      var c = str.charAt(i);\n      if (null == c || Number(c) != c) {\n        --i;\n        break;\n      }\n      p.id += str.charAt(i);\n      if (i === str.length) break;\n    }\n    p.id = Number(p.id);\n  }\n\n  // look up json data\n  if (str.charAt(++i)) {\n    var payload = tryParse(str.substr(i));\n    var isPayloadValid = payload !== false && (p.type === exports.ERROR || isArray(payload));\n    if (isPayloadValid) {\n      p.data = payload;\n    } else {\n      return error('invalid payload');\n    }\n  }\n\n  debug('decoded %s as %j', str, p);\n  return p;\n}\n\nfunction tryParse(str) {\n  try {\n    return JSON.parse(str);\n  } catch(e){\n    return false;\n  }\n}\n\n/**\n * Deallocates a parser's resources\n *\n * @api public\n */\n\nDecoder.prototype.destroy = function() {\n  if (this.reconstructor) {\n    this.reconstructor.finishedReconstruction();\n  }\n};\n\n/**\n * A manager of a binary event's 'buffer sequence'. Should\n * be constructed whenever a packet of type BINARY_EVENT is\n * decoded.\n *\n * @param {Object} packet\n * @return {BinaryReconstructor} initialized reconstructor\n * @api private\n */\n\nfunction BinaryReconstructor(packet) {\n  this.reconPack = packet;\n  this.buffers = [];\n}\n\n/**\n * Method to be called when binary data received from connection\n * after a BINARY_EVENT packet.\n *\n * @param {Buffer | ArrayBuffer} binData - the raw binary data received\n * @return {null | Object} returns null if more binary data is expected or\n *   a reconstructed packet object if all buffers have been received.\n * @api private\n */\n\nBinaryReconstructor.prototype.takeBinaryData = function(binData) {\n  this.buffers.push(binData);\n  if (this.buffers.length === this.reconPack.attachments) { // done with buffer list\n    var packet = binary.reconstructPacket(this.reconPack, this.buffers);\n    this.finishedReconstruction();\n    return packet;\n  }\n  return null;\n};\n\n/**\n * Cleans up binary packet reconstruction variables.\n *\n * @api private\n */\n\nBinaryReconstructor.prototype.finishedReconstruction = function() {\n  this.reconPack = null;\n  this.buffers = [];\n};\n\nfunction error(msg) {\n  return {\n    type: exports.ERROR,\n    data: 'parser error: ' + msg\n  };\n}\n","/*global Blob,File*/\n\n/**\n * Module requirements\n */\n\nvar isArray = require('isarray');\nvar isBuf = require('./is-buffer');\nvar toString = Object.prototype.toString;\nvar withNativeBlob = typeof Blob === 'function' || (typeof Blob !== 'undefined' && toString.call(Blob) === '[object BlobConstructor]');\nvar withNativeFile = typeof File === 'function' || (typeof File !== 'undefined' && toString.call(File) === '[object FileConstructor]');\n\n/**\n * Replaces every Buffer | ArrayBuffer in packet with a numbered placeholder.\n * Anything with blobs or files should be fed through removeBlobs before coming\n * here.\n *\n * @param {Object} packet - socket.io event packet\n * @return {Object} with deconstructed packet and list of buffers\n * @api public\n */\n\nexports.deconstructPacket = function(packet) {\n  var buffers = [];\n  var packetData = packet.data;\n  var pack = packet;\n  pack.data = _deconstructPacket(packetData, buffers);\n  pack.attachments = buffers.length; // number of binary 'attachments'\n  return {packet: pack, buffers: buffers};\n};\n\nfunction _deconstructPacket(data, buffers) {\n  if (!data) return data;\n\n  if (isBuf(data)) {\n    var placeholder = { _placeholder: true, num: buffers.length };\n    buffers.push(data);\n    return placeholder;\n  } else if (isArray(data)) {\n    var newData = new Array(data.length);\n    for (var i = 0; i < data.length; i++) {\n      newData[i] = _deconstructPacket(data[i], buffers);\n    }\n    return newData;\n  } else if (typeof data === 'object' && !(data instanceof Date)) {\n    var newData = {};\n    for (var key in data) {\n      newData[key] = _deconstructPacket(data[key], buffers);\n    }\n    return newData;\n  }\n  return data;\n}\n\n/**\n * Reconstructs a binary packet from its placeholder packet and buffers\n *\n * @param {Object} packet - event packet with placeholders\n * @param {Array} buffers - binary buffers to put in placeholder positions\n * @return {Object} reconstructed packet\n * @api public\n */\n\nexports.reconstructPacket = function(packet, buffers) {\n  packet.data = _reconstructPacket(packet.data, buffers);\n  packet.attachments = undefined; // no longer useful\n  return packet;\n};\n\nfunction _reconstructPacket(data, buffers) {\n  if (!data) return data;\n\n  if (data && data._placeholder) {\n    return buffers[data.num]; // appropriate buffer (should be natural order anyway)\n  } else if (isArray(data)) {\n    for (var i = 0; i < data.length; i++) {\n      data[i] = _reconstructPacket(data[i], buffers);\n    }\n  } else if (typeof data === 'object') {\n    for (var key in data) {\n      data[key] = _reconstructPacket(data[key], buffers);\n    }\n  }\n\n  return data;\n}\n\n/**\n * Asynchronously removes Blobs or Files from data via\n * FileReader's readAsArrayBuffer method. Used before encoding\n * data as msgpack. Calls callback with the blobless data.\n *\n * @param {Object} data\n * @param {Function} callback\n * @api private\n */\n\nexports.removeBlobs = function(data, callback) {\n  function _removeBlobs(obj, curKey, containingObject) {\n    if (!obj) return obj;\n\n    // convert any blob\n    if ((withNativeBlob && obj instanceof Blob) ||\n        (withNativeFile && obj instanceof File)) {\n      pendingBlobs++;\n\n      // async filereader\n      var fileReader = new FileReader();\n      fileReader.onload = function() { // this.result == arraybuffer\n        if (containingObject) {\n          containingObject[curKey] = this.result;\n        }\n        else {\n          bloblessData = this.result;\n        }\n\n        // if nothing pending its callback time\n        if(! --pendingBlobs) {\n          callback(bloblessData);\n        }\n      };\n\n      fileReader.readAsArrayBuffer(obj); // blob -> arraybuffer\n    } else if (isArray(obj)) { // handle array\n      for (var i = 0; i < obj.length; i++) {\n        _removeBlobs(obj[i], i, obj);\n      }\n    } else if (typeof obj === 'object' && !isBuf(obj)) { // and object\n      for (var key in obj) {\n        _removeBlobs(obj[key], key, obj);\n      }\n    }\n  }\n\n  var pendingBlobs = 0;\n  var bloblessData = data;\n  _removeBlobs(bloblessData);\n  if (!pendingBlobs) {\n    callback(bloblessData);\n  }\n};\n"],"sourceRoot":""}