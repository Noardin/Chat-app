{"version":3,"sources":["webpack:///./src/node_modules/engine.io-parser/lib/keys.js","webpack:///./src/node_modules/engine.io-parser/lib/browser.js","webpack:///./src/node_modules/engine.io-parser/lib/utf8.js"],"names":["module","exports","Object","keys","obj","arr","has","prototype","hasOwnProperty","i","call","push","base64encoder","__webpack_require__","hasBinary","sliceBuffer","after","utf8","ArrayBuffer","isAndroid","navigator","test","userAgent","isPhantomJS","dontSendBlobs","protocol","packets","open","close","ping","pong","message","upgrade","noop","packetslist","err","type","data","Blob","encodeBase64Object","packet","callback","encodeArrayBuffer","supportsBinary","encodeBase64Packet","contentArray","Uint8Array","resultBuffer","byteLength","length","buffer","encodeBlobAsArrayBuffer","fr","FileReader","onload","encodePacket","result","readAsArrayBuffer","encodeBlob","blob","tryDecode","decode","strict","e","map","ary","each","done","Array","next","eachWithIndex","el","cb","error","msg","utf8encode","undefined","base64","encoded","encode","String","b64data","b64","split","readAsDataURL","fromCharCode","apply","typed","basic","btoa","decodePacket","binaryType","utf8decode","charAt","decodeBase64Packet","substr","Number","substring","asArray","rest","encodePayload","isBinary","encodePayloadAsBlob","encodePayloadAsArrayBuffer","setLengthHeader","encodeOne","doneCallback","results","join","decodePayload","decodePayloadAsBinary","n","l","chr","ret","encodedPackets","totalLength","reduce","acc","p","len","toString","resultArray","bufferIndex","forEach","isString","ab","view","charCodeAt","lenStr","parseInt","binaryIdentifier","size","lengthAry","bufferTail","buffers","tailArray","msgLength","total","byteArray","byteCount","byteIndex","stringFromCharCode","ucs2decode","string","value","extra","output","counter","ucs2encode","array","index","checkScalarValue","codePoint","Error","toUpperCase","createByte","shift","encodeCodePoint","symbol","opts","codePoints","byteString","readContinuationByte","continuationByte","decodeSymbol","byte1","byte2","byte3","byte4","tmp","version"],"mappings":"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","file":"js/chunk-vendors~d1d77ecf.cdb5bd94.js","sourcesContent":["\n/**\n * Gets the keys for an object.\n *\n * @return {Array} keys\n * @api private\n */\n\nmodule.exports = Object.keys || function keys (obj){\n  var arr = [];\n  var has = Object.prototype.hasOwnProperty;\n\n  for (var i in obj) {\n    if (has.call(obj, i)) {\n      arr.push(i);\n    }\n  }\n  return arr;\n};\n","/**\n * Module dependencies.\n */\n\nvar keys = require('./keys');\nvar hasBinary = require('has-binary2');\nvar sliceBuffer = require('arraybuffer.slice');\nvar after = require('after');\nvar utf8 = require('./utf8');\n\nvar base64encoder;\nif (typeof ArrayBuffer !== 'undefined') {\n  base64encoder = require('base64-arraybuffer');\n}\n\n/**\n * Check if we are running an android browser. That requires us to use\n * ArrayBuffer with polling transports...\n *\n * http://ghinda.net/jpeg-blob-ajax-android/\n */\n\nvar isAndroid = typeof navigator !== 'undefined' && /Android/i.test(navigator.userAgent);\n\n/**\n * Check if we are running in PhantomJS.\n * Uploading a Blob with PhantomJS does not work correctly, as reported here:\n * https://github.com/ariya/phantomjs/issues/11395\n * @type boolean\n */\nvar isPhantomJS = typeof navigator !== 'undefined' && /PhantomJS/i.test(navigator.userAgent);\n\n/**\n * When true, avoids using Blobs to encode payloads.\n * @type boolean\n */\nvar dontSendBlobs = isAndroid || isPhantomJS;\n\n/**\n * Current protocol version.\n */\n\nexports.protocol = 3;\n\n/**\n * Packet types.\n */\n\nvar packets = exports.packets = {\n    open:     0    // non-ws\n  , close:    1    // non-ws\n  , ping:     2\n  , pong:     3\n  , message:  4\n  , upgrade:  5\n  , noop:     6\n};\n\nvar packetslist = keys(packets);\n\n/**\n * Premade error packet.\n */\n\nvar err = { type: 'error', data: 'parser error' };\n\n/**\n * Create a blob api even for blob builder when vendor prefixes exist\n */\n\nvar Blob = require('blob');\n\n/**\n * Encodes a packet.\n *\n *     <packet type id> [ <data> ]\n *\n * Example:\n *\n *     5hello world\n *     3\n *     4\n *\n * Binary is encoded in an identical principle\n *\n * @api private\n */\n\nexports.encodePacket = function (packet, supportsBinary, utf8encode, callback) {\n  if (typeof supportsBinary === 'function') {\n    callback = supportsBinary;\n    supportsBinary = false;\n  }\n\n  if (typeof utf8encode === 'function') {\n    callback = utf8encode;\n    utf8encode = null;\n  }\n\n  var data = (packet.data === undefined)\n    ? undefined\n    : packet.data.buffer || packet.data;\n\n  if (typeof ArrayBuffer !== 'undefined' && data instanceof ArrayBuffer) {\n    return encodeArrayBuffer(packet, supportsBinary, callback);\n  } else if (typeof Blob !== 'undefined' && data instanceof Blob) {\n    return encodeBlob(packet, supportsBinary, callback);\n  }\n\n  // might be an object with { base64: true, data: dataAsBase64String }\n  if (data && data.base64) {\n    return encodeBase64Object(packet, callback);\n  }\n\n  // Sending data as a utf-8 string\n  var encoded = packets[packet.type];\n\n  // data fragment is optional\n  if (undefined !== packet.data) {\n    encoded += utf8encode ? utf8.encode(String(packet.data), { strict: false }) : String(packet.data);\n  }\n\n  return callback('' + encoded);\n\n};\n\nfunction encodeBase64Object(packet, callback) {\n  // packet data is an object { base64: true, data: dataAsBase64String }\n  var message = 'b' + exports.packets[packet.type] + packet.data.data;\n  return callback(message);\n}\n\n/**\n * Encode packet helpers for binary types\n */\n\nfunction encodeArrayBuffer(packet, supportsBinary, callback) {\n  if (!supportsBinary) {\n    return exports.encodeBase64Packet(packet, callback);\n  }\n\n  var data = packet.data;\n  var contentArray = new Uint8Array(data);\n  var resultBuffer = new Uint8Array(1 + data.byteLength);\n\n  resultBuffer[0] = packets[packet.type];\n  for (var i = 0; i < contentArray.length; i++) {\n    resultBuffer[i+1] = contentArray[i];\n  }\n\n  return callback(resultBuffer.buffer);\n}\n\nfunction encodeBlobAsArrayBuffer(packet, supportsBinary, callback) {\n  if (!supportsBinary) {\n    return exports.encodeBase64Packet(packet, callback);\n  }\n\n  var fr = new FileReader();\n  fr.onload = function() {\n    exports.encodePacket({ type: packet.type, data: fr.result }, supportsBinary, true, callback);\n  };\n  return fr.readAsArrayBuffer(packet.data);\n}\n\nfunction encodeBlob(packet, supportsBinary, callback) {\n  if (!supportsBinary) {\n    return exports.encodeBase64Packet(packet, callback);\n  }\n\n  if (dontSendBlobs) {\n    return encodeBlobAsArrayBuffer(packet, supportsBinary, callback);\n  }\n\n  var length = new Uint8Array(1);\n  length[0] = packets[packet.type];\n  var blob = new Blob([length.buffer, packet.data]);\n\n  return callback(blob);\n}\n\n/**\n * Encodes a packet with binary data in a base64 string\n *\n * @param {Object} packet, has `type` and `data`\n * @return {String} base64 encoded message\n */\n\nexports.encodeBase64Packet = function(packet, callback) {\n  var message = 'b' + exports.packets[packet.type];\n  if (typeof Blob !== 'undefined' && packet.data instanceof Blob) {\n    var fr = new FileReader();\n    fr.onload = function() {\n      var b64 = fr.result.split(',')[1];\n      callback(message + b64);\n    };\n    return fr.readAsDataURL(packet.data);\n  }\n\n  var b64data;\n  try {\n    b64data = String.fromCharCode.apply(null, new Uint8Array(packet.data));\n  } catch (e) {\n    // iPhone Safari doesn't let you apply with typed arrays\n    var typed = new Uint8Array(packet.data);\n    var basic = new Array(typed.length);\n    for (var i = 0; i < typed.length; i++) {\n      basic[i] = typed[i];\n    }\n    b64data = String.fromCharCode.apply(null, basic);\n  }\n  message += btoa(b64data);\n  return callback(message);\n};\n\n/**\n * Decodes a packet. Changes format to Blob if requested.\n *\n * @return {Object} with `type` and `data` (if any)\n * @api private\n */\n\nexports.decodePacket = function (data, binaryType, utf8decode) {\n  if (data === undefined) {\n    return err;\n  }\n  // String data\n  if (typeof data === 'string') {\n    if (data.charAt(0) === 'b') {\n      return exports.decodeBase64Packet(data.substr(1), binaryType);\n    }\n\n    if (utf8decode) {\n      data = tryDecode(data);\n      if (data === false) {\n        return err;\n      }\n    }\n    var type = data.charAt(0);\n\n    if (Number(type) != type || !packetslist[type]) {\n      return err;\n    }\n\n    if (data.length > 1) {\n      return { type: packetslist[type], data: data.substring(1) };\n    } else {\n      return { type: packetslist[type] };\n    }\n  }\n\n  var asArray = new Uint8Array(data);\n  var type = asArray[0];\n  var rest = sliceBuffer(data, 1);\n  if (Blob && binaryType === 'blob') {\n    rest = new Blob([rest]);\n  }\n  return { type: packetslist[type], data: rest };\n};\n\nfunction tryDecode(data) {\n  try {\n    data = utf8.decode(data, { strict: false });\n  } catch (e) {\n    return false;\n  }\n  return data;\n}\n\n/**\n * Decodes a packet encoded in a base64 string\n *\n * @param {String} base64 encoded message\n * @return {Object} with `type` and `data` (if any)\n */\n\nexports.decodeBase64Packet = function(msg, binaryType) {\n  var type = packetslist[msg.charAt(0)];\n  if (!base64encoder) {\n    return { type: type, data: { base64: true, data: msg.substr(1) } };\n  }\n\n  var data = base64encoder.decode(msg.substr(1));\n\n  if (binaryType === 'blob' && Blob) {\n    data = new Blob([data]);\n  }\n\n  return { type: type, data: data };\n};\n\n/**\n * Encodes multiple messages (payload).\n *\n *     <length>:data\n *\n * Example:\n *\n *     11:hello world2:hi\n *\n * If any contents are binary, they will be encoded as base64 strings. Base64\n * encoded strings are marked with a b before the length specifier\n *\n * @param {Array} packets\n * @api private\n */\n\nexports.encodePayload = function (packets, supportsBinary, callback) {\n  if (typeof supportsBinary === 'function') {\n    callback = supportsBinary;\n    supportsBinary = null;\n  }\n\n  var isBinary = hasBinary(packets);\n\n  if (supportsBinary && isBinary) {\n    if (Blob && !dontSendBlobs) {\n      return exports.encodePayloadAsBlob(packets, callback);\n    }\n\n    return exports.encodePayloadAsArrayBuffer(packets, callback);\n  }\n\n  if (!packets.length) {\n    return callback('0:');\n  }\n\n  function setLengthHeader(message) {\n    return message.length + ':' + message;\n  }\n\n  function encodeOne(packet, doneCallback) {\n    exports.encodePacket(packet, !isBinary ? false : supportsBinary, false, function(message) {\n      doneCallback(null, setLengthHeader(message));\n    });\n  }\n\n  map(packets, encodeOne, function(err, results) {\n    return callback(results.join(''));\n  });\n};\n\n/**\n * Async array map using after\n */\n\nfunction map(ary, each, done) {\n  var result = new Array(ary.length);\n  var next = after(ary.length, done);\n\n  var eachWithIndex = function(i, el, cb) {\n    each(el, function(error, msg) {\n      result[i] = msg;\n      cb(error, result);\n    });\n  };\n\n  for (var i = 0; i < ary.length; i++) {\n    eachWithIndex(i, ary[i], next);\n  }\n}\n\n/*\n * Decodes data when a payload is maybe expected. Possible binary contents are\n * decoded from their base64 representation\n *\n * @param {String} data, callback method\n * @api public\n */\n\nexports.decodePayload = function (data, binaryType, callback) {\n  if (typeof data !== 'string') {\n    return exports.decodePayloadAsBinary(data, binaryType, callback);\n  }\n\n  if (typeof binaryType === 'function') {\n    callback = binaryType;\n    binaryType = null;\n  }\n\n  var packet;\n  if (data === '') {\n    // parser error - ignoring payload\n    return callback(err, 0, 1);\n  }\n\n  var length = '', n, msg;\n\n  for (var i = 0, l = data.length; i < l; i++) {\n    var chr = data.charAt(i);\n\n    if (chr !== ':') {\n      length += chr;\n      continue;\n    }\n\n    if (length === '' || (length != (n = Number(length)))) {\n      // parser error - ignoring payload\n      return callback(err, 0, 1);\n    }\n\n    msg = data.substr(i + 1, n);\n\n    if (length != msg.length) {\n      // parser error - ignoring payload\n      return callback(err, 0, 1);\n    }\n\n    if (msg.length) {\n      packet = exports.decodePacket(msg, binaryType, false);\n\n      if (err.type === packet.type && err.data === packet.data) {\n        // parser error in individual packet - ignoring payload\n        return callback(err, 0, 1);\n      }\n\n      var ret = callback(packet, i + n, l);\n      if (false === ret) return;\n    }\n\n    // advance cursor\n    i += n;\n    length = '';\n  }\n\n  if (length !== '') {\n    // parser error - ignoring payload\n    return callback(err, 0, 1);\n  }\n\n};\n\n/**\n * Encodes multiple messages (payload) as binary.\n *\n * <1 = binary, 0 = string><number from 0-9><number from 0-9>[...]<number\n * 255><data>\n *\n * Example:\n * 1 3 255 1 2 3, if the binary contents are interpreted as 8 bit integers\n *\n * @param {Array} packets\n * @return {ArrayBuffer} encoded payload\n * @api private\n */\n\nexports.encodePayloadAsArrayBuffer = function(packets, callback) {\n  if (!packets.length) {\n    return callback(new ArrayBuffer(0));\n  }\n\n  function encodeOne(packet, doneCallback) {\n    exports.encodePacket(packet, true, true, function(data) {\n      return doneCallback(null, data);\n    });\n  }\n\n  map(packets, encodeOne, function(err, encodedPackets) {\n    var totalLength = encodedPackets.reduce(function(acc, p) {\n      var len;\n      if (typeof p === 'string'){\n        len = p.length;\n      } else {\n        len = p.byteLength;\n      }\n      return acc + len.toString().length + len + 2; // string/binary identifier + separator = 2\n    }, 0);\n\n    var resultArray = new Uint8Array(totalLength);\n\n    var bufferIndex = 0;\n    encodedPackets.forEach(function(p) {\n      var isString = typeof p === 'string';\n      var ab = p;\n      if (isString) {\n        var view = new Uint8Array(p.length);\n        for (var i = 0; i < p.length; i++) {\n          view[i] = p.charCodeAt(i);\n        }\n        ab = view.buffer;\n      }\n\n      if (isString) { // not true binary\n        resultArray[bufferIndex++] = 0;\n      } else { // true binary\n        resultArray[bufferIndex++] = 1;\n      }\n\n      var lenStr = ab.byteLength.toString();\n      for (var i = 0; i < lenStr.length; i++) {\n        resultArray[bufferIndex++] = parseInt(lenStr[i]);\n      }\n      resultArray[bufferIndex++] = 255;\n\n      var view = new Uint8Array(ab);\n      for (var i = 0; i < view.length; i++) {\n        resultArray[bufferIndex++] = view[i];\n      }\n    });\n\n    return callback(resultArray.buffer);\n  });\n};\n\n/**\n * Encode as Blob\n */\n\nexports.encodePayloadAsBlob = function(packets, callback) {\n  function encodeOne(packet, doneCallback) {\n    exports.encodePacket(packet, true, true, function(encoded) {\n      var binaryIdentifier = new Uint8Array(1);\n      binaryIdentifier[0] = 1;\n      if (typeof encoded === 'string') {\n        var view = new Uint8Array(encoded.length);\n        for (var i = 0; i < encoded.length; i++) {\n          view[i] = encoded.charCodeAt(i);\n        }\n        encoded = view.buffer;\n        binaryIdentifier[0] = 0;\n      }\n\n      var len = (encoded instanceof ArrayBuffer)\n        ? encoded.byteLength\n        : encoded.size;\n\n      var lenStr = len.toString();\n      var lengthAry = new Uint8Array(lenStr.length + 1);\n      for (var i = 0; i < lenStr.length; i++) {\n        lengthAry[i] = parseInt(lenStr[i]);\n      }\n      lengthAry[lenStr.length] = 255;\n\n      if (Blob) {\n        var blob = new Blob([binaryIdentifier.buffer, lengthAry.buffer, encoded]);\n        doneCallback(null, blob);\n      }\n    });\n  }\n\n  map(packets, encodeOne, function(err, results) {\n    return callback(new Blob(results));\n  });\n};\n\n/*\n * Decodes data when a payload is maybe expected. Strings are decoded by\n * interpreting each byte as a key code for entries marked to start with 0. See\n * description of encodePayloadAsBinary\n *\n * @param {ArrayBuffer} data, callback method\n * @api public\n */\n\nexports.decodePayloadAsBinary = function (data, binaryType, callback) {\n  if (typeof binaryType === 'function') {\n    callback = binaryType;\n    binaryType = null;\n  }\n\n  var bufferTail = data;\n  var buffers = [];\n\n  while (bufferTail.byteLength > 0) {\n    var tailArray = new Uint8Array(bufferTail);\n    var isString = tailArray[0] === 0;\n    var msgLength = '';\n\n    for (var i = 1; ; i++) {\n      if (tailArray[i] === 255) break;\n\n      // 310 = char length of Number.MAX_VALUE\n      if (msgLength.length > 310) {\n        return callback(err, 0, 1);\n      }\n\n      msgLength += tailArray[i];\n    }\n\n    bufferTail = sliceBuffer(bufferTail, 2 + msgLength.length);\n    msgLength = parseInt(msgLength);\n\n    var msg = sliceBuffer(bufferTail, 0, msgLength);\n    if (isString) {\n      try {\n        msg = String.fromCharCode.apply(null, new Uint8Array(msg));\n      } catch (e) {\n        // iPhone Safari doesn't let you apply to typed arrays\n        var typed = new Uint8Array(msg);\n        msg = '';\n        for (var i = 0; i < typed.length; i++) {\n          msg += String.fromCharCode(typed[i]);\n        }\n      }\n    }\n\n    buffers.push(msg);\n    bufferTail = sliceBuffer(bufferTail, msgLength);\n  }\n\n  var total = buffers.length;\n  buffers.forEach(function(buffer, i) {\n    callback(exports.decodePacket(buffer, binaryType, true), i, total);\n  });\n};\n","/*! https://mths.be/utf8js v2.1.2 by @mathias */\n\nvar stringFromCharCode = String.fromCharCode;\n\n// Taken from https://mths.be/punycode\nfunction ucs2decode(string) {\n\tvar output = [];\n\tvar counter = 0;\n\tvar length = string.length;\n\tvar value;\n\tvar extra;\n\twhile (counter < length) {\n\t\tvalue = string.charCodeAt(counter++);\n\t\tif (value >= 0xD800 && value <= 0xDBFF && counter < length) {\n\t\t\t// high surrogate, and there is a next character\n\t\t\textra = string.charCodeAt(counter++);\n\t\t\tif ((extra & 0xFC00) == 0xDC00) { // low surrogate\n\t\t\t\toutput.push(((value & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000);\n\t\t\t} else {\n\t\t\t\t// unmatched surrogate; only append this code unit, in case the next\n\t\t\t\t// code unit is the high surrogate of a surrogate pair\n\t\t\t\toutput.push(value);\n\t\t\t\tcounter--;\n\t\t\t}\n\t\t} else {\n\t\t\toutput.push(value);\n\t\t}\n\t}\n\treturn output;\n}\n\n// Taken from https://mths.be/punycode\nfunction ucs2encode(array) {\n\tvar length = array.length;\n\tvar index = -1;\n\tvar value;\n\tvar output = '';\n\twhile (++index < length) {\n\t\tvalue = array[index];\n\t\tif (value > 0xFFFF) {\n\t\t\tvalue -= 0x10000;\n\t\t\toutput += stringFromCharCode(value >>> 10 & 0x3FF | 0xD800);\n\t\t\tvalue = 0xDC00 | value & 0x3FF;\n\t\t}\n\t\toutput += stringFromCharCode(value);\n\t}\n\treturn output;\n}\n\nfunction checkScalarValue(codePoint, strict) {\n\tif (codePoint >= 0xD800 && codePoint <= 0xDFFF) {\n\t\tif (strict) {\n\t\t\tthrow Error(\n\t\t\t\t'Lone surrogate U+' + codePoint.toString(16).toUpperCase() +\n\t\t\t\t' is not a scalar value'\n\t\t\t);\n\t\t}\n\t\treturn false;\n\t}\n\treturn true;\n}\n/*--------------------------------------------------------------------------*/\n\nfunction createByte(codePoint, shift) {\n\treturn stringFromCharCode(((codePoint >> shift) & 0x3F) | 0x80);\n}\n\nfunction encodeCodePoint(codePoint, strict) {\n\tif ((codePoint & 0xFFFFFF80) == 0) { // 1-byte sequence\n\t\treturn stringFromCharCode(codePoint);\n\t}\n\tvar symbol = '';\n\tif ((codePoint & 0xFFFFF800) == 0) { // 2-byte sequence\n\t\tsymbol = stringFromCharCode(((codePoint >> 6) & 0x1F) | 0xC0);\n\t}\n\telse if ((codePoint & 0xFFFF0000) == 0) { // 3-byte sequence\n\t\tif (!checkScalarValue(codePoint, strict)) {\n\t\t\tcodePoint = 0xFFFD;\n\t\t}\n\t\tsymbol = stringFromCharCode(((codePoint >> 12) & 0x0F) | 0xE0);\n\t\tsymbol += createByte(codePoint, 6);\n\t}\n\telse if ((codePoint & 0xFFE00000) == 0) { // 4-byte sequence\n\t\tsymbol = stringFromCharCode(((codePoint >> 18) & 0x07) | 0xF0);\n\t\tsymbol += createByte(codePoint, 12);\n\t\tsymbol += createByte(codePoint, 6);\n\t}\n\tsymbol += stringFromCharCode((codePoint & 0x3F) | 0x80);\n\treturn symbol;\n}\n\nfunction utf8encode(string, opts) {\n\topts = opts || {};\n\tvar strict = false !== opts.strict;\n\n\tvar codePoints = ucs2decode(string);\n\tvar length = codePoints.length;\n\tvar index = -1;\n\tvar codePoint;\n\tvar byteString = '';\n\twhile (++index < length) {\n\t\tcodePoint = codePoints[index];\n\t\tbyteString += encodeCodePoint(codePoint, strict);\n\t}\n\treturn byteString;\n}\n\n/*--------------------------------------------------------------------------*/\n\nfunction readContinuationByte() {\n\tif (byteIndex >= byteCount) {\n\t\tthrow Error('Invalid byte index');\n\t}\n\n\tvar continuationByte = byteArray[byteIndex] & 0xFF;\n\tbyteIndex++;\n\n\tif ((continuationByte & 0xC0) == 0x80) {\n\t\treturn continuationByte & 0x3F;\n\t}\n\n\t// If we end up here, it’s not a continuation byte\n\tthrow Error('Invalid continuation byte');\n}\n\nfunction decodeSymbol(strict) {\n\tvar byte1;\n\tvar byte2;\n\tvar byte3;\n\tvar byte4;\n\tvar codePoint;\n\n\tif (byteIndex > byteCount) {\n\t\tthrow Error('Invalid byte index');\n\t}\n\n\tif (byteIndex == byteCount) {\n\t\treturn false;\n\t}\n\n\t// Read first byte\n\tbyte1 = byteArray[byteIndex] & 0xFF;\n\tbyteIndex++;\n\n\t// 1-byte sequence (no continuation bytes)\n\tif ((byte1 & 0x80) == 0) {\n\t\treturn byte1;\n\t}\n\n\t// 2-byte sequence\n\tif ((byte1 & 0xE0) == 0xC0) {\n\t\tbyte2 = readContinuationByte();\n\t\tcodePoint = ((byte1 & 0x1F) << 6) | byte2;\n\t\tif (codePoint >= 0x80) {\n\t\t\treturn codePoint;\n\t\t} else {\n\t\t\tthrow Error('Invalid continuation byte');\n\t\t}\n\t}\n\n\t// 3-byte sequence (may include unpaired surrogates)\n\tif ((byte1 & 0xF0) == 0xE0) {\n\t\tbyte2 = readContinuationByte();\n\t\tbyte3 = readContinuationByte();\n\t\tcodePoint = ((byte1 & 0x0F) << 12) | (byte2 << 6) | byte3;\n\t\tif (codePoint >= 0x0800) {\n\t\t\treturn checkScalarValue(codePoint, strict) ? codePoint : 0xFFFD;\n\t\t} else {\n\t\t\tthrow Error('Invalid continuation byte');\n\t\t}\n\t}\n\n\t// 4-byte sequence\n\tif ((byte1 & 0xF8) == 0xF0) {\n\t\tbyte2 = readContinuationByte();\n\t\tbyte3 = readContinuationByte();\n\t\tbyte4 = readContinuationByte();\n\t\tcodePoint = ((byte1 & 0x07) << 0x12) | (byte2 << 0x0C) |\n\t\t\t(byte3 << 0x06) | byte4;\n\t\tif (codePoint >= 0x010000 && codePoint <= 0x10FFFF) {\n\t\t\treturn codePoint;\n\t\t}\n\t}\n\n\tthrow Error('Invalid UTF-8 detected');\n}\n\nvar byteArray;\nvar byteCount;\nvar byteIndex;\nfunction utf8decode(byteString, opts) {\n\topts = opts || {};\n\tvar strict = false !== opts.strict;\n\n\tbyteArray = ucs2decode(byteString);\n\tbyteCount = byteArray.length;\n\tbyteIndex = 0;\n\tvar codePoints = [];\n\tvar tmp;\n\twhile ((tmp = decodeSymbol(strict)) !== false) {\n\t\tcodePoints.push(tmp);\n\t}\n\treturn ucs2encode(codePoints);\n}\n\nmodule.exports = {\n\tversion: '2.1.2',\n\tencode: utf8encode,\n\tdecode: utf8decode\n};\n"],"sourceRoot":""}