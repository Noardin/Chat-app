{"version":3,"sources":["webpack:///./node_modules/vue-audio-visual/src/components/AvLine.js","webpack:///./node_modules/vue-audio-visual/src/components/AvWaveform.js","webpack:///./node_modules/vue-audio-visual/src/index.js"],"names":["props","lineWidth","type","Number","default","lineColor","String","Array","fftSize","AvLine","name","mixins","AvBase","[object Object]","audio","analyser","ctx","audioCtx","methods","mainLoop","frqBits","this","frequencyBinCount","step","canvWidth","data","Uint8Array","x","_setCanvas","getByteFrequencyData","strokeStyle","isArray","fillGradient","beginPath","reverse","moveTo","canvHeight","_drawLine","lineTo","stroke","requestAnimationFrame","w","h","canvColor","canvFillColor","gradient","createLinearGradient","offset","clearRect","forEach","color","addColorStop","length","fillStyle","fillRect","y","v","i","components_AvLine","AvWaveform_props","playedLineWidth","playedLineColor","noplayedLineWidth","noplayedLineColor","playtime","Boolean","playtimeWithMs","playtimeFontSize","playtimeFontFamily","playtimeFontColor","playtimeTextBottom","playtimeSlider","playtimeSliderColor","playtimeSliderWidth","playtimeClickable","AvWaveform","ctxWrapper","duration","peaks","conf","responseType","onDownloadProgress","downloadProgress","axios_default","a","get","src","then","response","decode","catch","err","console","error","log","setAnalyser","AudioContext","decodeAudioData","audioBuffer","setPeaks","buffer","min","max","top","bottom","segSize","Math","ceil","width","height","c","numberOfChannels","getChannelData","s","start","end","addEventListener","e","updateTime","waveform","time","currentTime","playX","draw","slice","drawSlider","drawTime","timeFormat","timeSec","frmStr","parseFloat","isNaN","sec","ms","substr","timeStr","textWidth","measureText","textX","textY","font","fillText","offsetX","ev","progressX","round","loaded","total","components_AvWaveform","AVPlugin","install","Vue","window","webkitAudioContext","mozAudioContext","msAudioContext","webkitRequestAnimationFrame","mozRequestAnimationFrame","msRequestAnimationFrame","component","AvBars","AvCircle","prototype","$avAudioRefs","__webpack_exports__"],"mappings":"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","file":"js/chunk-vendors~f51f6df3.9a0616be.js","sourcesContent":["import BaseMixin from './AvBase'\n\n/**\n * Component props\n */\nconst props = {\n  /**\n   * prop: 'line-width'\n   * Draw line width in px\n   */\n  lineWidth: {\n    type: Number,\n    default: 2\n  },\n  /**\n   * prop: 'line-color'\n   * Draw line color or gradient array\n   */\n  lineColor: {\n    type: [String, Array],\n    default: '#9F9'\n  },\n  /**\n   * prop: 'fft-size'\n   * Represents the window size in samples that is used when performing\n   * a Fast Fourier Transform (FFT) to get frequency domain data.\n   * Must be power of 2 between 2^5 and 2^15\n   * Default: 128\n   */\n  fftSize: {\n    type: Number,\n    default: 128\n  }\n}\n\n/**\n * Component AvLine\n */\nconst AvLine = {\n  name: 'av-line',\n  mixins: [ BaseMixin ],\n  props,\n  data () {\n    return {\n      audio: null,\n      analyser: null,\n      ctx: null,\n      audioCtx: null\n    }\n  },\n  methods: {\n    /**\n     * Main loop. Draws visualization.\n     */\n    mainLoop: function () {\n      const frqBits = this.analyser.frequencyBinCount\n      const step = (this.canvWidth / 2.0) / frqBits\n      const data = new Uint8Array(frqBits)\n      let x = 0\n\n      this._setCanvas()\n      this.analyser.getByteFrequencyData(data)\n\n      this.ctx.lineWidth = this.lineWidth\n      this.ctx.strokeStyle = Array.isArray(this.lineColor)\n        ? this.fillGradient(this.lineColor)\n        : this.lineColor\n      this.ctx.beginPath()\n\n      data.reverse()\n      this.ctx.moveTo(x, this.canvHeight / 2)\n      x = this._drawLine(data, x, step)\n      data.reverse()\n      x = this._drawLine(data, x, step)\n      this.ctx.lineTo(this.canvWidth, this.canvHeight / 2)\n      this.ctx.stroke()\n\n      requestAnimationFrame(this.mainLoop)\n    },\n    /**\n     * Canvas clear background fill\n     * @private\n     */\n    _setCanvas: function () {\n      const w = this.canvWidth\n      const h = this.canvHeight\n      const canvColor = this.canvFillColor\n      const gradient = this.ctx.createLinearGradient(w / 2, 0, w / 2, h)\n      let offset = 0\n      this.ctx.clearRect(0, 0, w, h)\n\n      if (!canvColor) return\n\n      if (Array.isArray(canvColor)) {\n        canvColor.forEach(color => {\n          gradient.addColorStop(offset, color)\n          offset += (1 / canvColor.length)\n        })\n        this.ctx.fillStyle = gradient\n      } else {\n        this.ctx.fillStyle = canvColor\n      }\n      this.ctx.fillRect(0, 0, w, h)\n    },\n    /**\n     * Draw line and return last X\n     * @private\n     */\n    _drawLine: function (data, x, step) {\n      const h = this.canvHeight\n      let y = 0\n      data.forEach((v, i) => {\n        // (h / 2) - v / 255 * (h / 2)\n        y = h * (255 - v) / 510\n        if (i % 2) y = h - y\n        this.ctx.lineTo(x, y)\n        x += step\n      })\n      return x\n    }\n  }\n}\n\nexport default AvLine\n","import axios from 'axios'\nimport BaseMixin from './AvBase'\n\n/**\n * Component props\n */\nconst props = {\n  /**\n   * prop: 'canv-width'\n   * Canvas element width. Default 500\n   */\n  canvWidth: {\n    type: Number,\n    default: 500\n  },\n  /**\n   * prop: 'canv-height'\n   * Canvas element height. Default 80\n   */\n  canvHeight: {\n    type: Number,\n    default: 80\n  },\n  /**\n   * prop: 'played-line-width'\n   * Waveform line width for played segment of audio\n   * Default: 0.5\n   */\n  playedLineWidth: {\n    type: Number,\n    default: 0.5\n  },\n  /**\n   * prop: 'played-line-color'\n   * Waveform line color for played segment of audio\n   * Default: navy\n   */\n  playedLineColor: {\n    type: String,\n    default: 'navy'\n  },\n  /**\n   * prop: 'noplayed-line-width'\n   * Waveform line width for not yet played segment of audio\n   * Default: 0.5\n   */\n  noplayedLineWidth: {\n    type: Number,\n    default: 0.5\n  },\n  /**\n   * prop: 'noplayed-line-color'\n   * Waveform line color for not yet played segment of audio\n   * Default: lime\n   */\n  noplayedLineColor: {\n    type: String,\n    default: 'lime'\n  },\n  /**\n   * prop: 'playtime'\n   * Display played time next to progress slider.\n   * Default: true\n   */\n  playtime: {\n    type: Boolean,\n    default: true\n  },\n  /**\n   * prop: 'playtime-with-ms'\n   * Display milliseconds in played when true.\n   * For example: 02:55.054\n   * Default: true\n   */\n  playtimeWithMs: {\n    type: Boolean,\n    default: true\n  },\n  /**\n   * prop: 'playtime-font-size'\n   * Played time print font size in pixels.\n   * Default: 12\n   */\n  playtimeFontSize: {\n    type: Number,\n    default: 12\n  },\n  /**\n   * prop: 'playtime-font-family'\n   * Played time print font family.\n   * Default: monospace\n   */\n  playtimeFontFamily: {\n    type: String,\n    default: 'monospace'\n  },\n  /**\n   * prop: 'playtime-font-color'\n   * Played time print font RGB color string.\n   * Default: grey\n   */\n  playtimeFontColor: {\n    type: String,\n    default: 'grey'\n  },\n  /**\n   * prop: 'playtime-text-bottom'\n   * Position playtime text bottom.\n   * Default on top.\n   * Default: false\n   */\n  playtimeTextBottom: {\n    type: Boolean,\n    default: false\n  },\n  /**\n   * prop: 'playtime-slider'\n   * Draw played slider\n   * Default: true\n   */\n  playtimeSlider: {\n    type: Boolean,\n    default: true\n  },\n  /**\n   * prop: 'playtime-slider-color'\n   * Played slider color\n   * Default: red\n   */\n  playtimeSliderColor: {\n    type: String,\n    default: 'red'\n  },\n  /**\n   * prop: 'playtime-slider-width'\n   * Played slider width\n   * Default: 1\n   */\n  playtimeSliderWidth: {\n    type: Number,\n    default: 1\n  },\n  /**\n   * prop: 'playtime-clickable'\n   * Allow click on waveform to change playtime.\n   * Default: true\n   */\n  playtimeClickable: {\n    type: Boolean,\n    default: true\n  }\n}\n\n/**\n * Component AvLine\n */\nconst AvWaveform = {\n  name: 'av-waveform',\n  mixins: [ BaseMixin ],\n  props,\n  data () {\n    return {\n      ctxWrapper: null,\n      ctx: null,\n      audio: null,\n      duration: null,\n      peaks: []\n    }\n  },\n  mounted () {\n    const conf = {\n      responseType: 'arraybuffer',\n      onDownloadProgress: this.downloadProgress\n    }\n    axios.get(this.audio.src, conf)\n      .then(response => this.decode(response))\n      .catch(err => {\n        console.error(`Failed to get file '${this.audio.src}'`)\n        console.log(err)\n      })\n  },\n  methods: {\n    // Stub set analyser method from Mixin AvBase\n    // as there is no need of analyser in that component\n    // this method is called from mixin mounted()\n    setAnalyser: function () {\n      /* istanbul ignore next */\n      return null\n    },\n    // Stub mainLoop method from Mixin AvBase as\n    // here different init method will be used.\n    // This method is called from mixin mounted()\n    mainLoop: function () {\n      /* istanbul ignore next */\n      return null\n    },\n    /**\n     * Decode audio source response array buffer\n     */\n    decode: function (response) {\n      /* istanbul ignore next */\n      const ctx = new AudioContext()\n      /* istanbul ignore next */\n      ctx.decodeAudioData(response.data)\n        .then(audioBuffer => this.setPeaks(audioBuffer))\n        .catch(err => {\n          console.error('Failed to decode audio data.')\n          console.log(err)\n        })\n    },\n    /**\n     * Set peaks array for waveform.\n     * For now use only one channel\n     */\n    setPeaks: function (buffer) {\n      const peaks = []\n      let min = 0\n      let max = 0\n      let top = 0\n      let bottom = 0\n      const segSize = Math.ceil(buffer.length / this.canvWidth)\n      const width = this.canvWidth\n      const height = this.canvHeight\n      this.duration = this.audio.duration\n\n      for (let c = 0; c < buffer.numberOfChannels; c++) {\n        const data = buffer.getChannelData(c)\n        for (let s = 0; s < width; s++) {\n          const start = ~~(s * segSize)\n          const end = ~~(start + segSize)\n          min = 0\n          max = 0\n          for (let i = start; i < end; i++) {\n            min = data[i] < min ? data[i] : min\n            max = data[i] > max ? data[i] : max\n          }\n          // merge multi channel data\n          if (peaks[s]) {\n            peaks[s][0] = peaks[s][0] < max ? max : peaks[s][0]\n            peaks[s][1] = peaks[s][1] > min ? min : peaks[s][1]\n          }\n          peaks[s] = [max, min]\n        }\n      }\n      // set peaks relativelly to canvas dimensions\n      for (let i = 0; i < peaks.length; i++) {\n        max = peaks[i][0]\n        min = peaks[i][1]\n        top = ((height / 2) - (max * height / 2))\n        bottom = ((height / 2) - (min * height / 2))\n        peaks[i] = [top, bottom === top ? top + 1 : bottom]\n      }\n      this.peaks = peaks\n\n      if (this.playtimeClickable) {\n        this.ctxWrapper.addEventListener('click', (e) => this.updateTime(e))\n      }\n      this.waveform()\n    },\n    /**\n     * Draw wave form.\n     */\n    waveform: function () {\n      const peaks = this.peaks\n      const time = this.audio.currentTime\n      const playX = this.playX(time)\n      let x = 0\n      this.ctx.clearRect(0, 0, this.canvWidth, this.canvHeight)\n      x = this.draw(peaks.slice(0, playX), this.playedLineWidth, this.playedLineColor, x)\n      this.draw(peaks.slice(playX), this.noplayedLineWidth, this.noplayedLineColor, x)\n      this.drawSlider(time)\n      this.drawTime(time)\n\n      requestAnimationFrame(this.waveform)\n    },\n    /**\n     * Draw segment.\n     */\n    draw: function (data, lineWidth, color, x) {\n      this.ctx.lineWidth = lineWidth\n      this.ctx.strokeStyle = color\n      this.ctx.beginPath()\n      data.forEach(v => {\n        this.ctx.moveTo(x, v[0])\n        this.ctx.lineTo(x, v[1])\n        x++\n      })\n      this.ctx.stroke()\n      return x\n    },\n    /**\n     * Formatted string of current play time.\n     * @param {Number} Current play time\n     * @return {String}\n     */\n    timeFormat: function (timeSec) {\n      let frmStr = ''\n      const time = parseFloat(timeSec)\n      if (isNaN(time)) {\n        return frmStr\n      }\n\n      const min = ~~(time / 60)\n      const sec = ~~(time % 60)\n      const ms = ~~(time % 1 * 1000)\n\n      frmStr = (min < 10) ? `0${min}:` : `${min}:`\n      frmStr += `0${sec}`.substr(-2)\n      if (this.playtimeWithMs) {\n        frmStr += '.' + `00${ms}`.substr(-3)\n      }\n\n      return frmStr\n    },\n    /**\n     * Draw play time next to slider.\n     * @param {Number} Played time sec.millisec.\n     * @return {Void}\n     */\n    drawTime: function (time) {\n      const timeStr = this.timeFormat(time)\n      const offset = 3\n      const textWidth = ~~this.ctx.measureText(timeStr).width\n      const playX = this.playX(time)\n      const textX = playX > (this.canvWidth - textWidth - offset)\n        ? playX - textWidth - offset\n        : playX + offset\n      const textY = this.playtimeTextBottom\n        ? this.canvHeight - this.playtimeFontSize + offset\n        : this.playtimeFontSize + offset\n      this.ctx.fillStyle = this.playtimeFontColor\n      this.ctx.font = `${this.playtimeFontSize}px ${this.playtimeFontFamily}`\n      this.ctx.fillText(timeStr, textX, textY)\n    },\n    /**\n     * Draw played slider.\n     * @param {Number} Played time sec.millisec.\n     * @return {Void}\n     */\n    drawSlider: function (time) {\n      const playX = this.playX(time)\n      this.ctx.lineWidth = this.playtimeSliderWidth\n      this.ctx.strokeStyle = this.playtimeSliderColor\n      this.ctx.beginPath()\n      this.ctx.moveTo(playX, 0)\n      this.ctx.lineTo(playX, this.canvHeight)\n      this.ctx.stroke()\n    },\n    /**\n     * Get x coodrinate for play time.\n     * @param {Number}\n     * @return {Number}\n     */\n    playX: function (time) {\n      return ~~(time / this.duration * this.canvWidth)\n    },\n    /**\n     * Audio playback update time callback.\n     * @param event\n     */\n    updateTime: function (e) {\n      this.audio.currentTime = e.offsetX / this.canvWidth * this.duration\n    },\n    /**\n     * Audio source download progress\n     */\n    downloadProgress: function (ev) {\n      const progressX = Math.round(ev.loaded / ev.total * this.canvWidth)\n      this.ctx.clearRect(0, 0, this.canvWidth, this.canvHeight)\n      this.ctx.beginPath()\n      this.ctx.strokeStyle = this.noplayedLineColor\n      this.ctx.moveTo(0, this.canvHeight / 2)\n      this.ctx.lineTo(progressX, this.canvHeight / 2)\n      this.ctx.stroke()\n    }\n  }\n}\nexport default AvWaveform\n","import AvBars from './components/AvBars'\nimport AvLine from './components/AvLine'\nimport AvCircle from './components/AvCircle'\nimport AvWaveform from './components/AvWaveform'\n\nconst AVPlugin = {}\n\nAVPlugin.install = function (Vue) {\n  // browsers compatibility\n  window.AudioContext = window.AudioContext || window.webkitAudioContext || window.mozAudioContext || window.msAudioContext\n  window.requestAnimationFrame = window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.msRequestAnimationFrame\n  // Components\n  Vue.component(AvBars.name, AvBars)\n  Vue.component(AvLine.name, AvLine)\n  Vue.component(AvCircle.name, AvCircle)\n  Vue.component(AvWaveform.name, AvWaveform)\n  Vue.prototype.$avAudioRefs = {}\n}\n\nexport default AVPlugin\n"],"sourceRoot":""}